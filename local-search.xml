<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>洗牌算法（Fisher–Yates Shuffle / Knuth Shuffle）</title>
    <link href="/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是洗牌算法"><a href="#1-什么是洗牌算法" class="headerlink" title="1. 什么是洗牌算法"></a>1. 什么是洗牌算法</h2><p>洗牌算法的目标是：</p><ul><li>将一个序列随机打乱顺序</li><li>保证所有排列出现的概率相等（等概率性）</li><li>时间复杂度 O(n)，空间复杂度 O(1)</li></ul><p>常见错误写法（有概率偏差）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>); <span class="hljs-comment">// ❌ 有概率偏差</span><br></code></pre></td></tr></table></figure><h2 id="2-Fisher–Yates-Shuffle（从后往前）"><a href="#2-Fisher–Yates-Shuffle（从后往前）" class="headerlink" title="2. Fisher–Yates Shuffle（从后往前）"></a>2. Fisher–Yates Shuffle（从后往前）</h2><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ul><li>从最后一个元素索引 i &#x3D; length-1 开始</li><li>在 [0, i] 范围内随机取一个索引 j</li><li>交换 arr[i] 和 arr[j]</li><li>每轮固定一个元素，不再改动</li></ul><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    [arr[i], arr[j]] = [arr[j], arr[i]];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Math-floor-作用"><a href="#3-Math-floor-作用" class="headerlink" title="3. Math.floor 作用"></a>3. Math.floor 作用</h2><p>Math.floor(x) → 返回 小于或等于 x 的最大整数（向下取整）</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.7</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.1</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(-<span class="hljs-number">3.1</span>) <span class="hljs-comment">// -4  注意负数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI 编程实践探索</title>
    <link href="/2025/08/25/AI/"/>
    <url>/2025/08/25/AI/</url>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="Context-Length"><a href="#Context-Length" class="headerlink" title="Context Length"></a>Context Length</h3><p>它限制了模型一次性交互中能够处理的最大token数量。这包括了用户输入的所有内容和模型生成的输出。可以将其类比为资源（如金钱或时间）的总量，你只能在总量内分配这些资源。对于大模型来说，这意味着输入的信息越多，留给输出的空间就越少，反之亦然。</p><h3 id="Context-Window"><a href="#Context-Window" class="headerlink" title="Context Window"></a>Context Window</h3><p>这是模型在生成每个新token时实际参考的前面内容的范围。可以将其类比为在某一特定时间内你能集中注意力的范围，就像你只能专注于手头的有限任务。Context Window决定了在生成过程中，模型可以参考的上下文信息的量。这有助于模型生成连贯且相关的文本，而不会因为参考过多的上下文而导致混乱或不相关的输出。（所以在面对复杂项目时，可以选择具有较长上下文窗口的模型，如claude-4或gpt-4.1等具有128k上下文窗口）</p><h3 id="128K上下文到底有多大"><a href="#128K上下文到底有多大" class="headerlink" title="128K上下文到底有多大"></a>128K上下文到底有多大</h3><p>模型都有一个最佳的处理区间，一般来说，保持在一半以下的上下文使用量是一个比较合适的区间，当超过这个区间后，模型可能会开始遗忘之前的信息或产生一些幻觉</p><p>下面是一个参考，128k的上下文到底能干些什么事情</p><h4 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h4><ul><li>一篇标准的学术论文通常有5000到10,000个标记。128K的上下文窗口可以处理10到20篇这样的论文内容。</li><li>一本小说，如《哈利·波特与魔法石》，大约有77,000个标记，128K上下文窗口可以处理接近两本这样的小说内容。</li></ul><h4 id="网页内容"><a href="#网页内容" class="headerlink" title="网页内容"></a>网页内容</h4><ul><li>一个典型的新闻网站主页大约有2000到5000个标记，128K上下文窗口可以处理20到60个这样的主页内容。</li><li>博客文章通常有1000到3000个标记，128K上下文窗口可以处理40到120篇博客文章内容。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>复杂的开源项目代码库，像TensorFlow的核心代码库，可能包含数百万行代码。128K上下文窗口可以处理一个中等复杂模块的完整代码，包括注释和文档。</li></ul><h4 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h4><ul><li>在对话场景中，128K标记相当于连续几百个长对话轮次，这对于复杂的客服或技术支持对话非常有用。</li></ul><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><h3 id="AI编程目标"><a href="#AI编程目标" class="headerlink" title="AI编程目标"></a>AI编程目标</h3><p>与AI进行有目标的对话，然后基于这个目标构建一个Markdown文档，通过Markdown让Agent自动生成代码</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在上面的交互优化需求中，将hover相机旁的高度显示作为一个最小任务包，让AI实现该部分功能</p><h3 id="开始对话"><a href="#开始对话" class="headerlink" title="开始对话"></a>开始对话</h3><p>新建一个ask对话，告诉AI要解决的问题，以及对这个问题初步的解决方法，然后通过@file和@docs给到Agent必要的上下文（这里可以让Agent快速了解已有项目的框架和背景）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>鼓励让Agent向我提问，比如：完成这个功能我还需要考虑什么？</li><li>让Agent提出多个不同的方案，然后它进行评估制定完整计划</li><li>输出对话</li></ul><h3 id="参考Prompt"><a href="#参考Prompt" class="headerlink" title="参考Prompt"></a>参考Prompt</h3><p>整理一下你的代码实施计划，输出一个完成计划（它应包括代码示例、引用相关源文件或相关代码片段），要让一个新来的程序员看懂这个计划，直接就可以写代码，你的计划要以Markdown格式输出</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>因为是通过转述给AI生成的代码，这个过程可能会丢失一些信息，比如设计稿中的小点，需求评审过程中讨论的事情，又或是实现过程中与交互&#x2F;产品讨论的事情</p><p>可以在运行后看表现是否和符合预期，可以通过继续对话或自行修改获取希望的效果</p><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="注意上下文长度"><a href="#注意上下文长度" class="headerlink" title="注意上下文长度"></a>注意上下文长度</h3><p>当对话过长或是context过多时（单次tokens过多时），对话的质量就会开始下降，因为Agent会开始遗漏一些细节</p><p>将任务分解成更小的块并开始新的会话有助于保持清晰度和专注度</p><h3 id="明确相关的源代码文件"><a href="#明确相关的源代码文件" class="headerlink" title="明确相关的源代码文件"></a>明确相关的源代码文件</h3><p>Agent不会自动查阅所有需要的源码。只要明确引导它读相关库代码，代码质量往往明显提升。比如将项目&#x2F;二方包接口文件也放入context，会极大提高代码中接口的正确使用。</p><h3 id="深刻理解需求-丰富知识储备"><a href="#深刻理解需求-丰富知识储备" class="headerlink" title="深刻理解需求&amp;丰富知识储备"></a>深刻理解需求&amp;丰富知识储备</h3><p>如果自己都没弄懂某个领域或不清楚具体的需求，Agent很难搭建出完美模块。抽出时间彻底理解需求和相关技术，实际上能大幅提高开发效率。</p><h2 id="写在最后面"><a href="#写在最后面" class="headerlink" title="写在最后面"></a>写在最后面</h2><h3 id="✅-推荐做法"><a href="#✅-推荐做法" class="headerlink" title="✅ 推荐做法"></a>✅ 推荐做法</h3><ul><li>任务拆解为最小可执行单元</li><li>提供精准的上下文信息</li><li>引导AI进行方案对比和评估</li><li>输出结构化的实施文档</li></ul><h3 id="❌-避免做法"><a href="#❌-避免做法" class="headerlink" title="❌ 避免做法"></a>❌ 避免做法</h3><ul><li>一次性塞入过多复杂需求</li><li>缺少项目背景上下文</li><li>期望AI理解所有业务细节</li><li>直接要求完整项目代码</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cline.bot/blog/building-advanced-software-with-cline-a-structured-approach">Building Advanced Software with Cline: A Structured Approach, January 15, 2025</a></li><li><a href="https://www.53ai.com/news/LargeLanguageModel/2024073165281.html">大模型｜”Context Length”和”Context Window”不再傻傻分不清楚！智识可乐 20240731</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks 实践：useEffect vs useLayoutEffect &amp; useRef vs createRef 深度解析</title>
    <link href="/2025/04/25/ReactHooks/"/>
    <url>/2025/04/25/ReactHooks/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在新人 onboarding 项目中，需要为智能视角组件注册位置信息以供引导弹窗使用。由于智能视角采用函数组件实现且 DOM 会动态更新，初期错误使用了 <code>createRef</code> 导致引导功能失效。</p><p><strong>问题现象</strong>：引导弹窗无法正确定位到智能视角组件位置<br><strong>根本原因</strong>：函数组件重渲染时 <code>createRef</code> 会创建新的 ref 对象，导致位置信息丢失<br><strong>解决方案</strong>：改用 <code>useRef</code> 确保 ref 对象在组件生命周期内保持一致</p><p>借此机会，深入学习了这些 Hook 的区别和最佳实践。</p><h2 id="2-useEffect-与-useLayoutEffect-的区别"><a href="#2-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="2. useEffect 与 useLayoutEffect 的区别"></a>2. useEffect 与 useLayoutEffect 的区别</h2><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 是 React 中常用的两个 Hook，但在触发时机和执行顺序上有重要区别。</p><h3 id="2-1-执行时机对比"><a href="#2-1-执行时机对比" class="headerlink" title="2.1 执行时机对比"></a>2.1 执行时机对比</h3><p><strong>React 渲染流程</strong>：</p><ol><li><strong>Render 阶段</strong>：执行函数组件，生成虚拟 DOM</li><li><strong>Commit 阶段</strong>：更新真实 DOM</li><li><strong>Layout 阶段</strong>：useLayoutEffect 执行（同步）</li><li><strong>Paint 阶段</strong>：浏览器绘制页面</li><li><strong>Effect 阶段</strong>：useEffect 执行（异步）</li></ol><p><strong>关键区别</strong>：</p><ul><li><code>useLayoutEffect</code>：在浏览器绘制<strong>之前</strong>同步执行，可能阻塞渲染</li><li><code>useEffect</code>：在浏览器绘制<strong>之后</strong>异步执行，不阻塞渲染</li></ul><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制前执行，可能阻塞渲染</span><br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useLayoutEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：DOM 测量、样式修改等需要在绘制前完成的操作</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制后异步执行，不阻塞渲染</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：API 调用、事件监听、数据获取等</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-使用建议"><a href="#2-3-使用建议" class="headerlink" title="2.3 使用建议"></a>2.3 使用建议</h3><p><strong>优先使用 <code>useEffect</code></strong>：</p><ul><li>不会阻塞页面渲染，提供更好的用户体验</li><li>适合处理不需要立即更新 UI 的副作用（网络请求、事件订阅等）</li></ul><p><strong>特定场景使用 <code>useLayoutEffect</code></strong>：</p><ul><li>需要在页面渲染前同步执行操作</li><li>DOM 测量和样式修改，避免视觉闪烁</li><li>需要立即获取 DOM 元素尺寸或位置信息</li></ul><h2 id="3-React-createRef-和-React-useRef-的区别"><a href="#3-React-createRef-和-React-useRef-的区别" class="headerlink" title="3. React.createRef 和 React.useRef 的区别"></a>3. React.createRef 和 React.useRef 的区别</h2><p><strong>核心区别</strong>：<code>useRef</code> 仅能用在函数组件，<code>createRef</code> 仅能用在类组件。</p><h3 id="3-1-实际问题分析"><a href="#3-1-实际问题分析" class="headerlink" title="3.1 实际问题分析"></a>3.1 实际问题分析</h3><p><strong>问题场景</strong>：智能视角组件需要为引导弹窗提供位置信息</p><p><strong>错误用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ❌ 错误：每次渲染都创建新的 ref</span><br>  <span class="hljs-keyword">const</span> viewRef = <span class="hljs-title class_">React</span>.<span class="hljs-property">createRef</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 由于 viewRef 每次都是新对象，引导系统无法正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正确用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ✅ 正确：整个组件生命周期中保持同一个 ref 对象</span><br>  <span class="hljs-keyword">const</span> viewRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// viewRef 对象保持不变，引导系统可以正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;, []); <span class="hljs-comment">// 空依赖数组，只注册一次</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-详细对比"><a href="#3-2-详细对比" class="headerlink" title="3.2 详细对比"></a>3.2 详细对比</h3><table><thead><tr><th>特性</th><th>createRef</th><th>useRef</th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>类组件</td><td>函数组件</td></tr><tr><td><strong>重新渲染行为</strong></td><td>每次创建新对象</td><td>保持同一对象</td></tr><tr><td><strong>初始值设置</strong></td><td>不支持参数</td><td>支持初始值参数</td></tr><tr><td><strong>性能</strong></td><td>开销较大</td><td>更高效</td></tr><tr><td><strong>推荐度</strong></td><td>仅类组件使用</td><td>现代 React 推荐</td></tr></tbody></table><h3 id="3-3-原理解析"><a href="#3-3-原理解析" class="headerlink" title="3.3 原理解析"></a>3.3 原理解析</h3><p><strong>createRef 在函数组件中的问题</strong>：</p><ul><li><code>createRef</code> 没有 Hooks 机制，每次函数组件执行都会重新创建</li><li>函数组件重渲染时，之前的 ref 引用会丢失</li></ul><p><strong>useRef 的优势</strong>：</p><ul><li>基于 Hooks 机制，React 内部维护引用的一致性</li><li>在组件整个生命周期中返回同一个 ref 对象</li></ul><h2 id="4-ref-更新的最佳实践"><a href="#4-ref-更新的最佳实践" class="headerlink" title="4. ref 更新的最佳实践"></a>4. ref 更新的最佳实践</h2><p>由于 Ref 是贯穿函数组件所有渲染周期的实例，理论上在任何地方都可以修改，但需要遵循 React 的最佳实践。</p><h3 id="4-1-推荐的更新时机"><a href="#4-1-推荐的更新时机" class="headerlink" title="4.1 推荐的更新时机"></a>4.1 推荐的更新时机</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [, forceUpdate] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 在事件处理器中更新</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    countRef.<span class="hljs-property">current</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-title function_">forceUpdate</span>(); <span class="hljs-comment">// 手动触发重渲染</span><br>  &#125;;<br>  <br>  <span class="hljs-comment">// ✅ 在 useEffect 中更新</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    countRef.<span class="hljs-property">current</span> = someCalculatedValue;<br>  &#125;, [dependency]);<br>  <br>  <span class="hljs-comment">// ❌ 避免在渲染期间直接更新</span><br>  <span class="hljs-comment">// countRef.current += 1; // 不要这样做</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Count: &#123;countRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-避免在-Render-Phase-修改-ref"><a href="#4-2-避免在-Render-Phase-修改-ref" class="headerlink" title="4.2 避免在 Render Phase 修改 ref"></a>4.2 避免在 Render Phase 修改 ref</h3><p>从 React 生命周期来看，Render Phase 阶段不允许副作用操作，因为这个阶段可能被 React 随时取消或重做。修改 ref 属于副作用操作，应该在 Commit Phase 阶段或回调函数中进行。</p><h2 id="5-使用决策指南"><a href="#5-使用决策指南" class="headerlink" title="5. 使用决策指南"></a>5. 使用决策指南</h2><h3 id="5-1-useEffect-vs-useLayoutEffect-选择流程"><a href="#5-1-useEffect-vs-useLayoutEffect-选择流程" class="headerlink" title="5.1 useEffect vs useLayoutEffect 选择流程"></a>5.1 useEffect vs useLayoutEffect 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">需要修改DOM样式/测量尺寸？<br>├─ 是 → useLayoutEffect（避免视觉闪烁）<br>└─ 否 → useEffect（不阻塞渲染，性能更好）<br></code></pre></td></tr></table></figure><h3 id="5-2-useRef-vs-createRef-选择流程"><a href="#5-2-useRef-vs-createRef-选择流程" class="headerlink" title="5.2 useRef vs createRef 选择流程"></a>5.2 useRef vs createRef 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>组件类型？<br>├─ 函数组件 → useRef<br>└─ 类组件 → createRef<br></code></pre></td></tr></table></figure><h2 id="6-常见陷阱和注意事项"><a href="#6-常见陷阱和注意事项" class="headerlink" title="6. 常见陷阱和注意事项"></a>6. 常见陷阱和注意事项</h2><h3 id="6-1-useLayoutEffect-注意事项"><a href="#6-1-useLayoutEffect-注意事项" class="headerlink" title="6.1 useLayoutEffect 注意事项"></a>6.1 useLayoutEffect 注意事项</h3><ul><li><strong>性能影响</strong>：避免在其中执行耗时操作，会阻塞页面渲染</li><li><strong>SSR 兼容性</strong>：在服务端渲染中会有警告，可能需要条件使用</li><li><strong>使用场景</strong>：仅在需要同步 DOM 操作时使用，大多数情况下 useEffect 更合适</li></ul><h3 id="6-2-useRef-注意事项"><a href="#6-2-useRef-注意事项" class="headerlink" title="6.2 useRef 注意事项"></a>6.2 useRef 注意事项</h3><ul><li><strong>不触发重渲染</strong>：修改 <code>ref.current</code> 不会触发组件重渲染</li><li><strong>更新时机</strong>：不要在渲染期间修改 ref，应在副作用或事件处理器中修改</li><li><strong>类型安全</strong>：在 TypeScript 中注意 ref 的类型定义和 null 检查</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 类型安全的 ref 使用</span><br><span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">focusInput</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 需要进行 null 检查</span><br>  <span class="hljs-keyword">if</span> (inputRef.<span class="hljs-property">current</span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ol><li><p><strong>useEffect vs useLayoutEffect</strong>：</p><ul><li>优先使用 <code>useEffect</code>，仅在需要同步 DOM 操作时使用 <code>useLayoutEffect</code></li><li>理解执行时机差异，选择合适的 Hook 避免性能问题</li></ul></li><li><p><strong>useRef vs createRef</strong>：</p><ul><li>函数组件必须使用 <code>useRef</code>，类组件使用 <code>createRef</code></li><li><code>useRef</code> 保证对象一致性，避免重渲染导致的引用丢失</li></ul></li><li><p><strong>最佳实践</strong>：</p><ul><li>遵循 React 生命周期规则，在合适的时机更新 ref</li><li>注意类型安全和 null 检查</li><li>理解每个 Hook 的特性，选择最适合的工具</li></ul></li></ol><p>通过这次问题排查和学习，不仅解决了引导弹窗的定位问题，更重要的是加深了对 React Hooks 机制的理解，为后续开发提供了坚实的基础。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>hi，这里是最爱的杂货铺</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="about-me"><a href="#about-me" class="headerlink" title="about me"></a>about me</h2><p><strong>tel</strong>：18258866903<br><strong>email</strong>：<a href="mailto:&#x72;&#x65;&#x6e;&#106;&#105;&#x65;&#45;&#108;&#x40;&#102;&#x6f;&#120;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109;">renjie-l@foxmail.com</a></p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><ul><li>杭州电子科技大学，硕士研究生，电子信息专业，2020.09 – 2023.06</li><li>ITMO UNIVERSITY(俄罗斯)，Master，Control Engineering专业，2020.09 – 2022.06</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"><a href="#基于强化学习的无人机负载无摆动轨迹生成（科研项目）" class="headerlink" title="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"></a>基于强化学习的无人机负载无摆动轨迹生成（科研项目）</h3><ul><li><strong>项目背景</strong>：浙江省新苗人才计划项目</li><li><strong>项目时间</strong>：2022.03 – 2023.06</li><li><strong>项目描述</strong>：针对无人机悬挂负载易摆动的问题，通过强化学习算法生成无摆动飞行轨迹，并在实际无人机系统中验证有效性。</li></ul><h2 id="所获奖励"><a href="#所获奖励" class="headerlink" title="所获奖励"></a>所获奖励</h2><table><thead><tr><th>获奖时间</th><th>奖励名称</th></tr></thead><tbody><tr><td>2021.07</td><td>第十六届中国研究生电子设计竞赛 华东赛区一等奖</td></tr><tr><td>2022.08</td><td>第八届浙江省“互联网+”创新创业大赛 银奖</td></tr><tr><td>2021.10</td><td>2021研究生学业奖学金（前10%）</td></tr><tr><td>2020.11</td><td>2020研究生学业奖学金（前20%）</td></tr></tbody></table><h2 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h2><ul><li>Renjie, L., &amp; Fan, Y. (2022). Deep Reinforcement Learning-based Swing-Free Trajectories Planning Algorithm for UAV with a Suspended Load. In Proceedings of the CAC CHINAAUTOMATIONCONGRESS 2022.</li></ul>]]></content>
    
  </entry>
  
  
  
</search>
