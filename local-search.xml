<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>洗牌算法（Fisher–Yates Shuffle / Knuth Shuffle）</title>
    <link href="/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是洗牌算法"><a href="#1-什么是洗牌算法" class="headerlink" title="1. 什么是洗牌算法"></a>1. 什么是洗牌算法</h2><p>洗牌算法的目标是：</p><ul><li>将一个序列随机打乱顺序</li><li>保证所有排列出现的概率相等（等概率性）</li><li>时间复杂度 O(n)，空间复杂度 O(1)</li></ul><p>常见错误写法（有概率偏差）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>); <span class="hljs-comment">// ❌ 有概率偏差</span><br></code></pre></td></tr></table></figure><h2 id="2-Fisher–Yates-Shuffle（从后往前）"><a href="#2-Fisher–Yates-Shuffle（从后往前）" class="headerlink" title="2. Fisher–Yates Shuffle（从后往前）"></a>2. Fisher–Yates Shuffle（从后往前）</h2><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ul><li>从最后一个元素索引 i &#x3D; length-1 开始</li><li>在 [0, i] 范围内随机取一个索引 j</li><li>交换 arr[i] 和 arr[j]</li><li>每轮固定一个元素，不再改动</li></ul><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    [arr[i], arr[j]] = [arr[j], arr[i]];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Math-floor-作用"><a href="#3-Math-floor-作用" class="headerlink" title="3. Math.floor 作用"></a>3. Math.floor 作用</h2><p>Math.floor(x) → 返回 小于或等于 x 的最大整数（向下取整）</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.7</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.1</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(-<span class="hljs-number">3.1</span>) <span class="hljs-comment">// -4  注意负数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI 编程实践探索</title>
    <link href="/2025/08/25/AI/"/>
    <url>/2025/08/25/AI/</url>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="Context-Length"><a href="#Context-Length" class="headerlink" title="Context Length"></a>Context Length</h3><p>它限制了模型一次性交互中能够处理的最大token数量。这包括了用户输入的所有内容和模型生成的输出。可以将其类比为资源（如金钱或时间）的总量，你只能在总量内分配这些资源。对于大模型来说，这意味着输入的信息越多，留给输出的空间就越少，反之亦然。</p><h3 id="Context-Window"><a href="#Context-Window" class="headerlink" title="Context Window"></a>Context Window</h3><p>这是模型在生成每个新token时实际参考的前面内容的范围。可以将其类比为在某一特定时间内你能集中注意力的范围，就像你只能专注于手头的有限任务。Context Window决定了在生成过程中，模型可以参考的上下文信息的量。这有助于模型生成连贯且相关的文本，而不会因为参考过多的上下文而导致混乱或不相关的输出。（所以在面对复杂项目时，可以选择具有较长上下文窗口的模型，如claude-4或gpt-4.1等具有128k上下文窗口）</p><h3 id="128K上下文到底有多大"><a href="#128K上下文到底有多大" class="headerlink" title="128K上下文到底有多大"></a>128K上下文到底有多大</h3><p>模型都有一个最佳的处理区间，一般来说，保持在一半以下的上下文使用量是一个比较合适的区间，当超过这个区间后，模型可能会开始遗忘之前的信息或产生一些幻觉</p><p>下面是一个参考，128k的上下文到底能干些什么事情</p><h4 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h4><ul><li>一篇标准的学术论文通常有5000到10,000个标记。128K的上下文窗口可以处理10到20篇这样的论文内容。</li><li>一本小说，如《哈利·波特与魔法石》，大约有77,000个标记，128K上下文窗口可以处理接近两本这样的小说内容。</li></ul><h4 id="网页内容"><a href="#网页内容" class="headerlink" title="网页内容"></a>网页内容</h4><ul><li>一个典型的新闻网站主页大约有2000到5000个标记，128K上下文窗口可以处理20到60个这样的主页内容。</li><li>博客文章通常有1000到3000个标记，128K上下文窗口可以处理40到120篇博客文章内容。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>复杂的开源项目代码库，像TensorFlow的核心代码库，可能包含数百万行代码。128K上下文窗口可以处理一个中等复杂模块的完整代码，包括注释和文档。</li></ul><h4 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h4><ul><li>在对话场景中，128K标记相当于连续几百个长对话轮次，这对于复杂的客服或技术支持对话非常有用。</li></ul><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><h3 id="AI编程目标"><a href="#AI编程目标" class="headerlink" title="AI编程目标"></a>AI编程目标</h3><p>与AI进行有目标的对话，然后基于这个目标构建一个Markdown文档，通过Markdown让Agent自动生成代码</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在上面的交互优化需求中，将hover相机旁的高度显示作为一个最小任务包，让AI实现该部分功能</p><h3 id="开始对话"><a href="#开始对话" class="headerlink" title="开始对话"></a>开始对话</h3><p>新建一个ask对话，告诉AI要解决的问题，以及对这个问题初步的解决方法，然后通过@file和@docs给到Agent必要的上下文（这里可以让Agent快速了解已有项目的框架和背景）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>鼓励让Agent向我提问，比如：完成这个功能我还需要考虑什么？</li><li>让Agent提出多个不同的方案，然后它进行评估制定完整计划</li><li>输出对话</li></ul><h3 id="参考Prompt"><a href="#参考Prompt" class="headerlink" title="参考Prompt"></a>参考Prompt</h3><p>整理一下你的代码实施计划，输出一个完成计划（它应包括代码示例、引用相关源文件或相关代码片段），要让一个新来的程序员看懂这个计划，直接就可以写代码，你的计划要以Markdown格式输出</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>因为是通过转述给AI生成的代码，这个过程可能会丢失一些信息，比如设计稿中的小点，需求评审过程中讨论的事情，又或是实现过程中与交互&#x2F;产品讨论的事情</p><p>可以在运行后看表现是否和符合预期，可以通过继续对话或自行修改获取希望的效果</p><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="注意上下文长度"><a href="#注意上下文长度" class="headerlink" title="注意上下文长度"></a>注意上下文长度</h3><p>当对话过长或是context过多时（单次tokens过多时），对话的质量就会开始下降，因为Agent会开始遗漏一些细节</p><p>将任务分解成更小的块并开始新的会话有助于保持清晰度和专注度</p><h3 id="明确相关的源代码文件"><a href="#明确相关的源代码文件" class="headerlink" title="明确相关的源代码文件"></a>明确相关的源代码文件</h3><p>Agent不会自动查阅所有需要的源码。只要明确引导它读相关库代码，代码质量往往明显提升。比如将项目&#x2F;二方包接口文件也放入context，会极大提高代码中接口的正确使用。</p><h3 id="深刻理解需求-丰富知识储备"><a href="#深刻理解需求-丰富知识储备" class="headerlink" title="深刻理解需求&amp;丰富知识储备"></a>深刻理解需求&amp;丰富知识储备</h3><p>如果自己都没弄懂某个领域或不清楚具体的需求，Agent很难搭建出完美模块。抽出时间彻底理解需求和相关技术，实际上能大幅提高开发效率。</p><h2 id="写在最后面"><a href="#写在最后面" class="headerlink" title="写在最后面"></a>写在最后面</h2><h3 id="✅-推荐做法"><a href="#✅-推荐做法" class="headerlink" title="✅ 推荐做法"></a>✅ 推荐做法</h3><ul><li>任务拆解为最小可执行单元</li><li>提供精准的上下文信息</li><li>引导AI进行方案对比和评估</li><li>输出结构化的实施文档</li></ul><h3 id="❌-避免做法"><a href="#❌-避免做法" class="headerlink" title="❌ 避免做法"></a>❌ 避免做法</h3><ul><li>一次性塞入过多复杂需求</li><li>缺少项目背景上下文</li><li>期望AI理解所有业务细节</li><li>直接要求完整项目代码</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cline.bot/blog/building-advanced-software-with-cline-a-structured-approach">Building Advanced Software with Cline: A Structured Approach, January 15, 2025</a></li><li><a href="https://www.53ai.com/news/LargeLanguageModel/2024073165281.html">大模型｜”Context Length”和”Context Window”不再傻傻分不清楚！智识可乐 20240731</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks 实践：useEffect vs useLayoutEffect &amp; useRef vs createRef 深度解析</title>
    <link href="/2025/04/25/ReactHooks/"/>
    <url>/2025/04/25/ReactHooks/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在某次开发项目中，需要为一个组件注册位置信息以供引导弹窗使用。由于该组件采用函数组件实现且 DOM 会动态更新，初期错误使用了 <code>createRef</code> 导致引导功能失效。</p><p><strong>问题现象</strong>：引导弹窗无法正确定位到组件位置<br><strong>根本原因</strong>：函数组件重渲染时 <code>createRef</code> 会创建新的 ref 对象，导致位置信息丢失<br><strong>解决方案</strong>：改用 <code>useRef</code> 确保 ref 对象在组件生命周期内保持一致</p><p>借此机会，深入学习了这些 Hook 的区别和最佳实践。</p><h2 id="2-useEffect-与-useLayoutEffect-的区别"><a href="#2-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="2. useEffect 与 useLayoutEffect 的区别"></a>2. useEffect 与 useLayoutEffect 的区别</h2><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 是 React 中常用的两个 Hook，但在触发时机和执行顺序上有重要区别。</p><h3 id="2-1-执行时机对比"><a href="#2-1-执行时机对比" class="headerlink" title="2.1 执行时机对比"></a>2.1 执行时机对比</h3><p><strong>React 渲染流程</strong>：</p><ol><li><strong>Render 阶段</strong>：执行函数组件，生成虚拟 DOM</li><li><strong>Commit 阶段</strong>：更新真实 DOM</li><li><strong>Layout 阶段</strong>：useLayoutEffect 执行（同步）</li><li><strong>Paint 阶段</strong>：浏览器绘制页面</li><li><strong>Effect 阶段</strong>：useEffect 执行（异步）</li></ol><p><strong>关键区别</strong>：</p><ul><li><code>useLayoutEffect</code>：在浏览器绘制<strong>之前</strong>同步执行，可能阻塞渲染</li><li><code>useEffect</code>：在浏览器绘制<strong>之后</strong>异步执行，不阻塞渲染</li></ul><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制前执行，可能阻塞渲染</span><br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useLayoutEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：DOM 测量、样式修改等需要在绘制前完成的操作</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制后异步执行，不阻塞渲染</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：API 调用、事件监听、数据获取等</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-使用建议"><a href="#2-3-使用建议" class="headerlink" title="2.3 使用建议"></a>2.3 使用建议</h3><p><strong>优先使用 <code>useEffect</code></strong>：</p><ul><li>不会阻塞页面渲染，提供更好的用户体验</li><li>适合处理不需要立即更新 UI 的副作用（网络请求、事件订阅等）</li></ul><p><strong>特定场景使用 <code>useLayoutEffect</code></strong>：</p><ul><li>需要在页面渲染前同步执行操作</li><li>DOM 测量和样式修改，避免视觉闪烁</li><li>需要立即获取 DOM 元素尺寸或位置信息</li></ul><h2 id="3-React-createRef-和-React-useRef-的区别"><a href="#3-React-createRef-和-React-useRef-的区别" class="headerlink" title="3. React.createRef 和 React.useRef 的区别"></a>3. React.createRef 和 React.useRef 的区别</h2><p><strong>核心区别</strong>：<code>useRef</code> 仅能用在函数组件，<code>createRef</code> 仅能用在类组件。</p><h3 id="3-1-实际问题分析"><a href="#3-1-实际问题分析" class="headerlink" title="3.1 实际问题分析"></a>3.1 实际问题分析</h3><p><strong>问题场景</strong>：智能视角组件需要为引导弹窗提供位置信息</p><p><strong>错误用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ❌ 错误：每次渲染都创建新的 ref</span><br>  <span class="hljs-keyword">const</span> viewRef = <span class="hljs-title class_">React</span>.<span class="hljs-property">createRef</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 由于 viewRef 每次都是新对象，引导系统无法正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正确用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ✅ 正确：整个组件生命周期中保持同一个 ref 对象</span><br>  <span class="hljs-keyword">const</span> viewRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// viewRef 对象保持不变，引导系统可以正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;, []); <span class="hljs-comment">// 空依赖数组，只注册一次</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-详细对比"><a href="#3-2-详细对比" class="headerlink" title="3.2 详细对比"></a>3.2 详细对比</h3><table><thead><tr><th>特性</th><th>createRef</th><th>useRef</th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>类组件</td><td>函数组件</td></tr><tr><td><strong>重新渲染行为</strong></td><td>每次创建新对象</td><td>保持同一对象</td></tr><tr><td><strong>初始值设置</strong></td><td>不支持参数</td><td>支持初始值参数</td></tr><tr><td><strong>性能</strong></td><td>开销较大</td><td>更高效</td></tr><tr><td><strong>推荐度</strong></td><td>仅类组件使用</td><td>现代 React 推荐</td></tr></tbody></table><h3 id="3-3-原理解析"><a href="#3-3-原理解析" class="headerlink" title="3.3 原理解析"></a>3.3 原理解析</h3><p><strong>createRef 在函数组件中的问题</strong>：</p><ul><li><code>createRef</code> 没有 Hooks 机制，每次函数组件执行都会重新创建</li><li>函数组件重渲染时，之前的 ref 引用会丢失</li></ul><p><strong>useRef 的优势</strong>：</p><ul><li>基于 Hooks 机制，React 内部维护引用的一致性</li><li>在组件整个生命周期中返回同一个 ref 对象</li></ul><h2 id="4-ref-更新的最佳实践"><a href="#4-ref-更新的最佳实践" class="headerlink" title="4. ref 更新的最佳实践"></a>4. ref 更新的最佳实践</h2><p>由于 Ref 是贯穿函数组件所有渲染周期的实例，理论上在任何地方都可以修改，但需要遵循 React 的最佳实践。</p><h3 id="4-1-推荐的更新时机"><a href="#4-1-推荐的更新时机" class="headerlink" title="4.1 推荐的更新时机"></a>4.1 推荐的更新时机</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [, forceUpdate] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 在事件处理器中更新</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    countRef.<span class="hljs-property">current</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-title function_">forceUpdate</span>(); <span class="hljs-comment">// 手动触发重渲染</span><br>  &#125;;<br>  <br>  <span class="hljs-comment">// ✅ 在 useEffect 中更新</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    countRef.<span class="hljs-property">current</span> = someCalculatedValue;<br>  &#125;, [dependency]);<br>  <br>  <span class="hljs-comment">// ❌ 避免在渲染期间直接更新</span><br>  <span class="hljs-comment">// countRef.current += 1; // 不要这样做</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Count: &#123;countRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-避免在-Render-Phase-修改-ref"><a href="#4-2-避免在-Render-Phase-修改-ref" class="headerlink" title="4.2 避免在 Render Phase 修改 ref"></a>4.2 避免在 Render Phase 修改 ref</h3><p>从 React 生命周期来看，Render Phase 阶段不允许副作用操作，因为这个阶段可能被 React 随时取消或重做。修改 ref 属于副作用操作，应该在 Commit Phase 阶段或回调函数中进行。</p><h2 id="5-使用决策指南"><a href="#5-使用决策指南" class="headerlink" title="5. 使用决策指南"></a>5. 使用决策指南</h2><h3 id="5-1-useEffect-vs-useLayoutEffect-选择流程"><a href="#5-1-useEffect-vs-useLayoutEffect-选择流程" class="headerlink" title="5.1 useEffect vs useLayoutEffect 选择流程"></a>5.1 useEffect vs useLayoutEffect 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">需要修改DOM样式/测量尺寸？<br>├─ 是 → useLayoutEffect（避免视觉闪烁）<br>└─ 否 → useEffect（不阻塞渲染，性能更好）<br></code></pre></td></tr></table></figure><h3 id="5-2-useRef-vs-createRef-选择流程"><a href="#5-2-useRef-vs-createRef-选择流程" class="headerlink" title="5.2 useRef vs createRef 选择流程"></a>5.2 useRef vs createRef 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>组件类型？<br>├─ 函数组件 → useRef<br>└─ 类组件 → createRef<br></code></pre></td></tr></table></figure><h2 id="6-常见陷阱和注意事项"><a href="#6-常见陷阱和注意事项" class="headerlink" title="6. 常见陷阱和注意事项"></a>6. 常见陷阱和注意事项</h2><h3 id="6-1-useLayoutEffect-注意事项"><a href="#6-1-useLayoutEffect-注意事项" class="headerlink" title="6.1 useLayoutEffect 注意事项"></a>6.1 useLayoutEffect 注意事项</h3><ul><li><strong>性能影响</strong>：避免在其中执行耗时操作，会阻塞页面渲染</li><li><strong>SSR 兼容性</strong>：在服务端渲染中会有警告，可能需要条件使用</li><li><strong>使用场景</strong>：仅在需要同步 DOM 操作时使用，大多数情况下 useEffect 更合适</li></ul><h3 id="6-2-useRef-注意事项"><a href="#6-2-useRef-注意事项" class="headerlink" title="6.2 useRef 注意事项"></a>6.2 useRef 注意事项</h3><ul><li><strong>不触发重渲染</strong>：修改 <code>ref.current</code> 不会触发组件重渲染</li><li><strong>更新时机</strong>：不要在渲染期间修改 ref，应在副作用或事件处理器中修改</li><li><strong>类型安全</strong>：在 TypeScript 中注意 ref 的类型定义和 null 检查</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 类型安全的 ref 使用</span><br><span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">focusInput</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 需要进行 null 检查</span><br>  <span class="hljs-keyword">if</span> (inputRef.<span class="hljs-property">current</span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ol><li><p><strong>useEffect vs useLayoutEffect</strong>：</p><ul><li>优先使用 <code>useEffect</code>，仅在需要同步 DOM 操作时使用 <code>useLayoutEffect</code></li><li>理解执行时机差异，选择合适的 Hook 避免性能问题</li></ul></li><li><p><strong>useRef vs createRef</strong>：</p><ul><li>函数组件必须使用 <code>useRef</code>，类组件使用 <code>createRef</code></li><li><code>useRef</code> 保证对象一致性，避免重渲染导致的引用丢失</li></ul></li><li><p><strong>最佳实践</strong>：</p><ul><li>遵循 React 生命周期规则，在合适的时机更新 ref</li><li>注意类型安全和 null 检查</li><li>理解每个 Hook 的特性，选择最适合的工具</li></ul></li></ol><p>通过这次问题排查和学习，不仅解决了引导弹窗的定位问题，更重要的是加深了对 React Hooks 机制的理解，为后续开发提供了坚实的基础。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 GitHub Pages + Hexo 快速搭建个人博客</title>
    <link href="/2023/06/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/25/hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>拥有一个自己的博客站点是件非常酷炫的事情，利用 <strong>GitHub Pages</strong> 和 <strong>Hexo</strong> 可轻松实现这个目标。</p><blockquote><p>ps：GitLab 其实也支持 Pages 功能，但公司内网的该功能域名和证书支持均被禁用，实用性较低，故不展开。</p></blockquote><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-GitHub-创建个人仓库"><a href="#1-GitHub-创建个人仓库" class="headerlink" title="1. GitHub 创建个人仓库"></a>1. GitHub 创建个人仓库</h3><ol><li>登录 GitHub 账号，点击页面右上角的 <strong>New repository</strong> 创建新仓库。</li><li>仓库名必须为固定格式：<code>用户名.github.io</code>（将“用户名”替换为你的 GitHub 账号名称）。<ul><li>示例：若 GitHub 账号名为 <code>zuiai-kjl</code>，则仓库名应为 <code>zuiai-kjl.github.io</code>。</li></ul></li></ol><h3 id="2-安装必要工具"><a href="#2-安装必要工具" class="headerlink" title="2. 安装必要工具"></a>2. 安装必要工具</h3><p>以下工具为搭建博客的基础依赖，需提前安装完成：</p><ul><li><strong>Git</strong>：版本控制工具，用于后续代码提交与部署。（默认大家已安装，此处略过详细步骤）</li><li><strong>Node.js</strong>：Hexo 基于 Node.js 运行，<strong>最低要求 v18 版本</strong>，推荐安装最新稳定版（可通过 <a href="https://nodejs.org/">Node.js 官网</a> 下载）。</li><li><strong>Hexo</strong>：博客框架，通过 npm 命令全局安装，终端执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、初始化-Hexo-博客"><a href="#二、初始化-Hexo-博客" class="headerlink" title="二、初始化 Hexo 博客"></a>二、初始化 Hexo 博客</h2><p>所有必备工具安装完成后，执行以下命令初始化博客项目：</p><ol><li>初始化博客文件夹（将 <code>&lt;folder&gt;</code> 替换为你想存放博客的文件夹名称，如 <code>my-blog</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br></code></pre></td></tr></table></figure></li><li>进入初始化好的博客目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;folder&gt;<br></code></pre></td></tr></table></figure></li><li>安装项目依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li></ol><p>执行完成后，你将得到一个 Hexo 博客的基础雏形，包含默认的目录结构和示例文章。</p><h2 id="三、写作：发布第一篇文章"><a href="#三、写作：发布第一篇文章" class="headerlink" title="三、写作：发布第一篇文章"></a>三、写作：发布第一篇文章</h2><h3 id="1-创建新文章"><a href="#1-创建新文章" class="headerlink" title="1. 创建新文章"></a>1. 创建新文章</h3><p>在博客根目录执行以下命令，创建一篇新的 Markdown 格式文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;this is title&quot;</span><br></code></pre></td></tr></table></figure><ul><li>该命令会在博客目录的 <code>source/_posts</code> 文件夹下生成一个名为 <code>this is title.md</code> 的文件。</li></ul><h3 id="2-编辑文章"><a href="#2-编辑文章" class="headerlink" title="2. 编辑文章"></a>2. 编辑文章</h3><ul><li>推荐使用 <strong>VS Code</strong> 或其他支持 Markdown 的编辑器（如 Typora）打开 <code>source/_posts/this is title.md</code> 文件进行编辑。</li><li>编辑器通常支持 Markdown 实时预览，可直观查看文章排版效果。</li></ul><h3 id="3-本地预览"><a href="#3-本地预览" class="headerlink" title="3. 本地预览"></a>3. 本地预览</h3><p>文章编辑完成后，在博客根目录执行以下两条命令，即可在本地浏览器预览博客效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态网页文件</span><br>hexo g<br><span class="hljs-comment"># 启动本地服务器</span><br>hexo s<br></code></pre></td></tr></table></figure><ul><li>执行 <code>hexo s</code> 后，终端会提示访问地址（默认是 <code>http://localhost:4000</code>），打开浏览器输入该地址即可查看新增的博文。</li></ul><h2 id="四、资源管理（以图片为例）"><a href="#四、资源管理（以图片为例）" class="headerlink" title="四、资源管理（以图片为例）"></a>四、资源管理（以图片为例）</h2><p>博客中常需插入图片，根据图片数量和大小，推荐两种资源管理方式：</p><h3 id="1-单篇文章独立资源文件夹（适合少量图片）"><a href="#1-单篇文章独立资源文件夹（适合少量图片）" class="headerlink" title="1. 单篇文章独立资源文件夹（适合少量图片）"></a>1. 单篇文章独立资源文件夹（适合少量图片）</h3><ul><li><strong>配置方式</strong>：在博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>）中，将 <code>post_asset_folder</code> 设为 <code>true</code>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><strong>效果</strong>：之后使用 <code>hexo new &quot;文章标题&quot;</code> 创建文章时，会在 <code>source/_posts</code> 下同时生成一个与文章同名的文件夹（如 <code>this is title</code> 文件夹）。</li><li><strong>使用</strong>：将该文章所需的图片放入同名文件夹，在 Markdown 中通过相对路径引用（如 <code>![图片描述](./this is title/图片名.jpg)</code>）。</li></ul><h3 id="2-图床（适合大量图片）"><a href="#2-图床（适合大量图片）" class="headerlink" title="2. 图床（适合大量图片）"></a>2. 图床（适合大量图片）</h3><p>若文章包含大量图片，直接放在 GitHub 会导致网页加载缓慢（尤其国内访问 GitHub 不稳定），此时推荐使用 <strong>图床</strong> 存储图片：</p><ul><li><strong>原理</strong>：将图片上传到图床平台，获取图片的外部链接，再在 Markdown 中通过外部链接引用图片（语法：<code>![图片描述](图片外部链接)</code>）。</li><li><strong>推荐免费图床</strong>：<ul><li><a href="https://www.superbed.cn/#pricing">Superbed</a></li><li><a href="https://imgtg.com/">imgtg</a></li><li><a href="https://chromewebstore.google.com/detail/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/pinjkilghdfhnkibhcangnpmcpdpmehk">微博图床（Chrome 插件）</a>（国内用户常用，需配合 Chrome 浏览器使用）</li></ul></li></ul><h2 id="五、部署：将博客发布到-GitHub-Pages"><a href="#五、部署：将博客发布到-GitHub-Pages" class="headerlink" title="五、部署：将博客发布到 GitHub Pages"></a>五、部署：将博客发布到 GitHub Pages</h2><p>本地预览无误后，需将博客部署到 GitHub Pages，让其他人可通过互联网访问你的博客。以下介绍 <strong>快速部署（推送生成好的网页文件）</strong> 方式（推荐新手使用）。</p><h3 id="1-配置部署信息"><a href="#1-配置部署信息" class="headerlink" title="1. 配置部署信息"></a>1. 配置部署信息</h3><ol><li><p>打开博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>），翻到文件末尾的 <code>deploy</code> 配置项，修改为以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">你的</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">仓库完整路径（需带</span> <span class="hljs-string">.git</span> <span class="hljs-string">后缀）</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署到仓库的 master 分支（部分新仓库默认分支为 main，需对应修改）</span><br></code></pre></td></tr></table></figure><ul><li>示例：若仓库地址为 <code>https://github.com/zuiai-kjl/zuiai-kjl.github.io</code>，则 <code>repo</code> 应填写 <code>https://github.com/zuiai-kjl/zuiai-kjl.github.io.git</code>。</li></ul></li><li><p>安装 Git 部署插件：在博客根目录执行以下命令，用于支持 Hexo 向 GitHub 推送文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-执行部署命令"><a href="#2-执行部署命令" class="headerlink" title="2. 执行部署命令"></a>2. 执行部署命令</h3><p>在博客根目录依次执行以下三条命令，完成部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理本地生成的旧静态文件（避免缓存问题）</span><br>hexo clean<br><span class="hljs-comment"># 重新生成最新的静态网页文件</span><br>hexo generate<br><span class="hljs-comment"># 部署到 GitHub Pages</span><br>hexo deploy<br></code></pre></td></tr></table></figure><ul><li>部署完成后，可进入 GitHub 仓库的 <strong>Actions</strong> 页面查看部署进度（若显示绿色对勾，则部署成功）。</li><li>访问博客：部署成功后，等待 1-2 分钟，在浏览器中输入 <code>https://用户名.github.io</code>（如 <code>https://zuiai-kjl.github.io</code>），即可访问你的公开博客。</li></ul><blockquote><p>ps：通过 <code>hexo deploy</code> 部署到 GitHub 的文件是 <strong>Markdown 转化后的静态 HTML 文件</strong>，而非原始的 Markdown 源码。若本地文件丢失或需在其他电脑修改博客，需额外备份源码（可通过 Git 单独管理源码分支）。</p></blockquote><h2 id="六、美化配置：更换-Hexo-主题"><a href="#六、美化配置：更换-Hexo-主题" class="headerlink" title="六、美化配置：更换 Hexo 主题"></a>六、美化配置：更换 Hexo 主题</h2><p>Hexo 拥有丰富的开源主题，可通过更换主题快速美化博客。以下以 <strong>Fluid 主题</strong> 为例（颜值高、可配置项丰富、文档齐全）。</p><h3 id="1-安装-Fluid-主题"><a href="#1-安装-Fluid-主题" class="headerlink" title="1. 安装 Fluid 主题"></a>1. 安装 Fluid 主题</h3><p>在博客根目录执行以下命令，通过 npm 安装 Fluid 主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><h3 id="2-启用主题"><a href="#2-启用主题" class="headerlink" title="2. 启用主题"></a>2. 启用主题</h3><ol><li><p>打开博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>），修改 <code>theme</code> 和 <code>language</code> 配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定使用 Fluid 主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定主题显示语言为中文（可按需修改为 en 等）</span><br></code></pre></td></tr></table></figure></li><li><p>复制主题配置文件：</p><ul><li>进入 <code>node_modules/hexo-theme-fluid</code> 目录，找到主题自带的 <code>_config.yml</code> 文件（该文件包含主题的所有配置项）。</li><li>在博客根目录新建一个名为 <code>_config.fluid.yml</code> 的文件，将上述 <code>_config.yml</code> 的内容复制进去（后续修改主题配置只需编辑 <code>_config.fluid.yml</code>，避免直接修改主题源码目录的文件，方便主题更新）。</li></ul></li></ol><h3 id="3-预览主题效果"><a href="#3-预览主题效果" class="headerlink" title="3. 预览主题效果"></a>3. 预览主题效果</h3><p>在博客根目录执行以下命令，本地预览美化后的博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><h3 id="4-自定义主题"><a href="#4-自定义主题" class="headerlink" title="4. 自定义主题"></a>4. 自定义主题</h3><p>Fluid 主题支持丰富的自定义配置（如导航栏、侧边栏、评论功能等），可参考官方文档进行配置：</p><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Fluid 主题官方文档</a></li></ul><p>更多 Hexo 主题可在 <a href="https://hexo.io/themes/">Hexo 官方主题库</a> 浏览选择。</p><h2 id="七、写在最后"><a href="#七、写在最后" class="headerlink" title="七、写在最后"></a>七、写在最后</h2><ul><li>示例博客：笔者花费小半天搭建的博客地址 → <a href="https://renjie-l.github.io/">https://renjie-l.github.io/</a></li><li>参考文档：<ul><li><a href="https://docs.github.com/cn/pages/quickstart">GitHub Pages 快速入门</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档（中文）</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>hi，这里是最爱的杂货铺</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="about-me"><a href="#about-me" class="headerlink" title="about me"></a>about me</h2><p><strong>tel</strong>：18258866903<br><strong>email</strong>：<a href="mailto:&#x72;&#x65;&#110;&#x6a;&#x69;&#101;&#45;&#108;&#64;&#102;&#111;&#x78;&#x6d;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;">renjie-l@foxmail.com</a></p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><ul><li>杭州电子科技大学，硕士研究生，电子信息专业，2020.09 – 2023.06</li><li>ITMO UNIVERSITY，Master，Control Engineering专业，2020.09 – 2022.06</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"><a href="#基于强化学习的无人机负载无摆动轨迹生成（科研项目）" class="headerlink" title="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"></a>基于强化学习的无人机负载无摆动轨迹生成（科研项目）</h3><ul><li><strong>项目背景</strong>：浙江省新苗人才计划项目</li><li><strong>项目时间</strong>：2022.03 – 2023.06</li><li><strong>项目描述</strong>：针对无人机悬挂负载易摆动的问题，通过强化学习算法生成无摆动飞行轨迹，并在实际无人机系统中验证有效性。</li></ul><h2 id="所获奖励"><a href="#所获奖励" class="headerlink" title="所获奖励"></a>所获奖励</h2><ul><li>2021年7月：第十六届中国研究生电子设计竞赛 华东赛区一等奖</li><li>2022年8月：第八届浙江省“互联网+”创新创业大赛 银奖</li><li>2021年10月：2021研究生学业奖学金（前10%）</li><li>2020年11月：2020研究生学业奖学金（前20%）</li></ul><h2 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h2><ul><li>Renjie, L., &amp; Fan, Y. (2022). Deep Reinforcement Learning-based Swing-Free Trajectories Planning Algorithm for UAV with a Suspended Load. In Proceedings of the CAC CHINAAUTOMATIONCONGRESS 2022.</li></ul>]]></content>
    
  </entry>
  
  
  
</search>
