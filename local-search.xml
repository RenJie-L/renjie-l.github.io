<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>洗牌算法（Fisher–Yates Shuffle / Knuth Shuffle）</title>
    <link href="/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2025/08/25/%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是洗牌算法"><a href="#1-什么是洗牌算法" class="headerlink" title="1. 什么是洗牌算法"></a>1. 什么是洗牌算法</h2><p>洗牌算法的目标是：</p><ul><li>将一个序列随机打乱顺序</li><li>保证所有排列出现的概率相等（等概率性）</li><li>时间复杂度 O(n)，空间复杂度 O(1)</li></ul><p>常见错误写法（有概率偏差）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>); <span class="hljs-comment">// ❌ 有概率偏差</span><br></code></pre></td></tr></table></figure><h2 id="2-Fisher–Yates-Shuffle（从后往前）"><a href="#2-Fisher–Yates-Shuffle（从后往前）" class="headerlink" title="2. Fisher–Yates Shuffle（从后往前）"></a>2. Fisher–Yates Shuffle（从后往前）</h2><h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ul><li>从最后一个元素索引 i &#x3D; length-1 开始</li><li>在 [0, i] 范围内随机取一个索引 j</li><li>交换 arr[i] 和 arr[j]</li><li>每轮固定一个元素，不再改动</li></ul><h3 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-built_in">number</span>[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>    [arr[i], arr[j]] = [arr[j], arr[i]];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Math-floor-作用"><a href="#3-Math-floor-作用" class="headerlink" title="3. Math.floor 作用"></a>3. Math.floor 作用</h2><p>Math.floor(x) → 返回 小于或等于 x 的最大整数（向下取整）</p><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.7</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-number">3.1</span>)  <span class="hljs-comment">// 3</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(-<span class="hljs-number">3.1</span>) <span class="hljs-comment">// -4  注意负数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI 编程实践探索</title>
    <link href="/2025/08/25/AI/"/>
    <url>/2025/08/25/AI/</url>
    
    <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="Context-Length"><a href="#Context-Length" class="headerlink" title="Context Length"></a>Context Length</h3><p>它限制了模型一次性交互中能够处理的最大token数量。这包括了用户输入的所有内容和模型生成的输出。可以将其类比为资源（如金钱或时间）的总量，你只能在总量内分配这些资源。对于大模型来说，这意味着输入的信息越多，留给输出的空间就越少，反之亦然。</p><h3 id="Context-Window"><a href="#Context-Window" class="headerlink" title="Context Window"></a>Context Window</h3><p>这是模型在生成每个新token时实际参考的前面内容的范围。可以将其类比为在某一特定时间内你能集中注意力的范围，就像你只能专注于手头的有限任务。Context Window决定了在生成过程中，模型可以参考的上下文信息的量。这有助于模型生成连贯且相关的文本，而不会因为参考过多的上下文而导致混乱或不相关的输出。（所以在面对复杂项目时，可以选择具有较长上下文窗口的模型，如claude-4或gpt-4.1等具有128k上下文窗口）</p><h3 id="128K上下文到底有多大"><a href="#128K上下文到底有多大" class="headerlink" title="128K上下文到底有多大"></a>128K上下文到底有多大</h3><p>模型都有一个最佳的处理区间，一般来说，保持在一半以下的上下文使用量是一个比较合适的区间，当超过这个区间后，模型可能会开始遗忘之前的信息或产生一些幻觉</p><p>下面是一个参考，128k的上下文到底能干些什么事情</p><h4 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h4><ul><li>一篇标准的学术论文通常有5000到10,000个标记。128K的上下文窗口可以处理10到20篇这样的论文内容。</li><li>一本小说，如《哈利·波特与魔法石》，大约有77,000个标记，128K上下文窗口可以处理接近两本这样的小说内容。</li></ul><h4 id="网页内容"><a href="#网页内容" class="headerlink" title="网页内容"></a>网页内容</h4><ul><li>一个典型的新闻网站主页大约有2000到5000个标记，128K上下文窗口可以处理20到60个这样的主页内容。</li><li>博客文章通常有1000到3000个标记，128K上下文窗口可以处理40到120篇博客文章内容。</li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul><li>复杂的开源项目代码库，像TensorFlow的核心代码库，可能包含数百万行代码。128K上下文窗口可以处理一个中等复杂模块的完整代码，包括注释和文档。</li></ul><h4 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h4><ul><li>在对话场景中，128K标记相当于连续几百个长对话轮次，这对于复杂的客服或技术支持对话非常有用。</li></ul><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><h3 id="AI编程目标"><a href="#AI编程目标" class="headerlink" title="AI编程目标"></a>AI编程目标</h3><p>与AI进行有目标的对话，然后基于这个目标构建一个Markdown文档，通过Markdown让Agent自动生成代码</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在上面的交互优化需求中，将hover相机旁的高度显示作为一个最小任务包，让AI实现该部分功能</p><h3 id="开始对话"><a href="#开始对话" class="headerlink" title="开始对话"></a>开始对话</h3><p>新建一个ask对话，告诉AI要解决的问题，以及对这个问题初步的解决方法，然后通过@file和@docs给到Agent必要的上下文（这里可以让Agent快速了解已有项目的框架和背景）</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>鼓励让Agent向我提问，比如：完成这个功能我还需要考虑什么？</li><li>让Agent提出多个不同的方案，然后它进行评估制定完整计划</li><li>输出对话</li></ul><h3 id="参考Prompt"><a href="#参考Prompt" class="headerlink" title="参考Prompt"></a>参考Prompt</h3><p>整理一下你的代码实施计划，输出一个完成计划（它应包括代码示例、引用相关源文件或相关代码片段），要让一个新来的程序员看懂这个计划，直接就可以写代码，你的计划要以Markdown格式输出</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>因为是通过转述给AI生成的代码，这个过程可能会丢失一些信息，比如设计稿中的小点，需求评审过程中讨论的事情，又或是实现过程中与交互&#x2F;产品讨论的事情</p><p>可以在运行后看表现是否和符合预期，可以通过继续对话或自行修改获取希望的效果</p><h2 id="一些小技巧"><a href="#一些小技巧" class="headerlink" title="一些小技巧"></a>一些小技巧</h2><h3 id="注意上下文长度"><a href="#注意上下文长度" class="headerlink" title="注意上下文长度"></a>注意上下文长度</h3><p>当对话过长或是context过多时（单次tokens过多时），对话的质量就会开始下降，因为Agent会开始遗漏一些细节</p><p>将任务分解成更小的块并开始新的会话有助于保持清晰度和专注度</p><h3 id="明确相关的源代码文件"><a href="#明确相关的源代码文件" class="headerlink" title="明确相关的源代码文件"></a>明确相关的源代码文件</h3><p>Agent不会自动查阅所有需要的源码。只要明确引导它读相关库代码，代码质量往往明显提升。比如将项目&#x2F;二方包接口文件也放入context，会极大提高代码中接口的正确使用。</p><h3 id="深刻理解需求-丰富知识储备"><a href="#深刻理解需求-丰富知识储备" class="headerlink" title="深刻理解需求&amp;丰富知识储备"></a>深刻理解需求&amp;丰富知识储备</h3><p>如果自己都没弄懂某个领域或不清楚具体的需求，Agent很难搭建出完美模块。抽出时间彻底理解需求和相关技术，实际上能大幅提高开发效率。</p><h2 id="写在最后面"><a href="#写在最后面" class="headerlink" title="写在最后面"></a>写在最后面</h2><h3 id="✅-推荐做法"><a href="#✅-推荐做法" class="headerlink" title="✅ 推荐做法"></a>✅ 推荐做法</h3><ul><li>任务拆解为最小可执行单元</li><li>提供精准的上下文信息</li><li>引导AI进行方案对比和评估</li><li>输出结构化的实施文档</li></ul><h3 id="❌-避免做法"><a href="#❌-避免做法" class="headerlink" title="❌ 避免做法"></a>❌ 避免做法</h3><ul><li>一次性塞入过多复杂需求</li><li>缺少项目背景上下文</li><li>期望AI理解所有业务细节</li><li>直接要求完整项目代码</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://cline.bot/blog/building-advanced-software-with-cline-a-structured-approach">Building Advanced Software with Cline: A Structured Approach, January 15, 2025</a></li><li><a href="https://www.53ai.com/news/LargeLanguageModel/2024073165281.html">大模型｜”Context Length”和”Context Window”不再傻傻分不清楚！智识可乐 20240731</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks 实践：useEffect vs useLayoutEffect &amp; useRef vs createRef 深度解析</title>
    <link href="/2025/04/25/ReactHooks/"/>
    <url>/2025/04/25/ReactHooks/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>在某次开发项目中，需要为一个组件注册位置信息以供引导弹窗使用。由于该组件采用函数组件实现且 DOM 会动态更新，初期错误使用了 <code>createRef</code> 导致引导功能失效。</p><p><strong>问题现象</strong>：引导弹窗无法正确定位到组件位置<br><strong>根本原因</strong>：函数组件重渲染时 <code>createRef</code> 会创建新的 ref 对象，导致位置信息丢失<br><strong>解决方案</strong>：改用 <code>useRef</code> 确保 ref 对象在组件生命周期内保持一致</p><p>借此机会，深入学习了这些 Hook 的区别和最佳实践。</p><h2 id="2-useEffect-与-useLayoutEffect-的区别"><a href="#2-useEffect-与-useLayoutEffect-的区别" class="headerlink" title="2. useEffect 与 useLayoutEffect 的区别"></a>2. useEffect 与 useLayoutEffect 的区别</h2><p><code>useEffect</code> 和 <code>useLayoutEffect</code> 是 React 中常用的两个 Hook，但在触发时机和执行顺序上有重要区别。</p><h3 id="2-1-执行时机对比"><a href="#2-1-执行时机对比" class="headerlink" title="2.1 执行时机对比"></a>2.1 执行时机对比</h3><p><strong>React 渲染流程</strong>：</p><ol><li><strong>Render 阶段</strong>：执行函数组件，生成虚拟 DOM</li><li><strong>Commit 阶段</strong>：更新真实 DOM</li><li><strong>Layout 阶段</strong>：useLayoutEffect 执行（同步）</li><li><strong>Paint 阶段</strong>：浏览器绘制页面</li><li><strong>Effect 阶段</strong>：useEffect 执行（异步）</li></ol><p><strong>关键区别</strong>：</p><ul><li><code>useLayoutEffect</code>：在浏览器绘制<strong>之前</strong>同步执行，可能阻塞渲染</li><li><code>useEffect</code>：在浏览器绘制<strong>之后</strong>异步执行，不阻塞渲染</li></ul><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制前执行，可能阻塞渲染</span><br>  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useLayoutEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：DOM 测量、样式修改等需要在绘制前完成的操作</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-comment">// 会在浏览器绘制后异步执行，不阻塞渲染</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;useEffect:&#x27;</span>, count);<br>    <span class="hljs-comment">// 适合：API 调用、事件监听、数据获取等</span><br>  &#125;, [count]);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-使用建议"><a href="#2-3-使用建议" class="headerlink" title="2.3 使用建议"></a>2.3 使用建议</h3><p><strong>优先使用 <code>useEffect</code></strong>：</p><ul><li>不会阻塞页面渲染，提供更好的用户体验</li><li>适合处理不需要立即更新 UI 的副作用（网络请求、事件订阅等）</li></ul><p><strong>特定场景使用 <code>useLayoutEffect</code></strong>：</p><ul><li>需要在页面渲染前同步执行操作</li><li>DOM 测量和样式修改，避免视觉闪烁</li><li>需要立即获取 DOM 元素尺寸或位置信息</li></ul><h2 id="3-React-createRef-和-React-useRef-的区别"><a href="#3-React-createRef-和-React-useRef-的区别" class="headerlink" title="3. React.createRef 和 React.useRef 的区别"></a>3. React.createRef 和 React.useRef 的区别</h2><p><strong>核心区别</strong>：<code>useRef</code> 仅能用在函数组件，<code>createRef</code> 仅能用在类组件。</p><h3 id="3-1-实际问题分析"><a href="#3-1-实际问题分析" class="headerlink" title="3.1 实际问题分析"></a>3.1 实际问题分析</h3><p><strong>问题场景</strong>：智能视角组件需要为引导弹窗提供位置信息</p><p><strong>错误用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ❌ 错误：每次渲染都创建新的 ref</span><br>  <span class="hljs-keyword">const</span> viewRef = <span class="hljs-title class_">React</span>.<span class="hljs-property">createRef</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;();<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 由于 viewRef 每次都是新对象，引导系统无法正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;);<br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>正确用法</strong>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SmartView</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ✅ 正确：整个组件生命周期中保持同一个 ref 对象</span><br>  <span class="hljs-keyword">const</span> viewRef = useRef&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;(<span class="hljs-literal">null</span>);<br>  <br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// viewRef 对象保持不变，引导系统可以正确获取位置</span><br>    <span class="hljs-title function_">registerGuidePosition</span>(<span class="hljs-string">&#x27;smart-view&#x27;</span>, viewRef);<br>  &#125;, []); <span class="hljs-comment">// 空依赖数组，只注册一次</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;viewRef&#125;</span>&gt;</span>智能视角内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-详细对比"><a href="#3-2-详细对比" class="headerlink" title="3.2 详细对比"></a>3.2 详细对比</h3><table><thead><tr><th>特性</th><th>createRef</th><th>useRef</th></tr></thead><tbody><tr><td><strong>使用场景</strong></td><td>类组件</td><td>函数组件</td></tr><tr><td><strong>重新渲染行为</strong></td><td>每次创建新对象</td><td>保持同一对象</td></tr><tr><td><strong>初始值设置</strong></td><td>不支持参数</td><td>支持初始值参数</td></tr><tr><td><strong>性能</strong></td><td>开销较大</td><td>更高效</td></tr><tr><td><strong>推荐度</strong></td><td>仅类组件使用</td><td>现代 React 推荐</td></tr></tbody></table><h3 id="3-3-原理解析"><a href="#3-3-原理解析" class="headerlink" title="3.3 原理解析"></a>3.3 原理解析</h3><p><strong>createRef 在函数组件中的问题</strong>：</p><ul><li><code>createRef</code> 没有 Hooks 机制，每次函数组件执行都会重新创建</li><li>函数组件重渲染时，之前的 ref 引用会丢失</li></ul><p><strong>useRef 的优势</strong>：</p><ul><li>基于 Hooks 机制，React 内部维护引用的一致性</li><li>在组件整个生命周期中返回同一个 ref 对象</li></ul><h2 id="4-ref-更新的最佳实践"><a href="#4-ref-更新的最佳实践" class="headerlink" title="4. ref 更新的最佳实践"></a>4. ref 更新的最佳实践</h2><p>由于 Ref 是贯穿函数组件所有渲染周期的实例，理论上在任何地方都可以修改，但需要遵循 React 的最佳实践。</p><h3 id="4-1-推荐的更新时机"><a href="#4-1-推荐的更新时机" class="headerlink" title="4.1 推荐的更新时机"></a>4.1 推荐的更新时机</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> countRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [, forceUpdate] = <span class="hljs-title function_">useReducer</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// ✅ 在事件处理器中更新</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    countRef.<span class="hljs-property">current</span> += <span class="hljs-number">1</span>;<br>    <span class="hljs-title function_">forceUpdate</span>(); <span class="hljs-comment">// 手动触发重渲染</span><br>  &#125;;<br>  <br>  <span class="hljs-comment">// ✅ 在 useEffect 中更新</span><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    countRef.<span class="hljs-property">current</span> = someCalculatedValue;<br>  &#125;, [dependency]);<br>  <br>  <span class="hljs-comment">// ❌ 避免在渲染期间直接更新</span><br>  <span class="hljs-comment">// countRef.current += 1; // 不要这样做</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>Count: &#123;countRef.current&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-避免在-Render-Phase-修改-ref"><a href="#4-2-避免在-Render-Phase-修改-ref" class="headerlink" title="4.2 避免在 Render Phase 修改 ref"></a>4.2 避免在 Render Phase 修改 ref</h3><p>从 React 生命周期来看，Render Phase 阶段不允许副作用操作，因为这个阶段可能被 React 随时取消或重做。修改 ref 属于副作用操作，应该在 Commit Phase 阶段或回调函数中进行。</p><h2 id="5-使用决策指南"><a href="#5-使用决策指南" class="headerlink" title="5. 使用决策指南"></a>5. 使用决策指南</h2><h3 id="5-1-useEffect-vs-useLayoutEffect-选择流程"><a href="#5-1-useEffect-vs-useLayoutEffect-选择流程" class="headerlink" title="5.1 useEffect vs useLayoutEffect 选择流程"></a>5.1 useEffect vs useLayoutEffect 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">需要修改DOM样式/测量尺寸？<br>├─ 是 → useLayoutEffect（避免视觉闪烁）<br>└─ 否 → useEffect（不阻塞渲染，性能更好）<br></code></pre></td></tr></table></figure><h3 id="5-2-useRef-vs-createRef-选择流程"><a href="#5-2-useRef-vs-createRef-选择流程" class="headerlink" title="5.2 useRef vs createRef 选择流程"></a>5.2 useRef vs createRef 选择流程</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>组件类型？<br>├─ 函数组件 → useRef<br>└─ 类组件 → createRef<br></code></pre></td></tr></table></figure><h2 id="6-常见陷阱和注意事项"><a href="#6-常见陷阱和注意事项" class="headerlink" title="6. 常见陷阱和注意事项"></a>6. 常见陷阱和注意事项</h2><h3 id="6-1-useLayoutEffect-注意事项"><a href="#6-1-useLayoutEffect-注意事项" class="headerlink" title="6.1 useLayoutEffect 注意事项"></a>6.1 useLayoutEffect 注意事项</h3><ul><li><strong>性能影响</strong>：避免在其中执行耗时操作，会阻塞页面渲染</li><li><strong>SSR 兼容性</strong>：在服务端渲染中会有警告，可能需要条件使用</li><li><strong>使用场景</strong>：仅在需要同步 DOM 操作时使用，大多数情况下 useEffect 更合适</li></ul><h3 id="6-2-useRef-注意事项"><a href="#6-2-useRef-注意事项" class="headerlink" title="6.2 useRef 注意事项"></a>6.2 useRef 注意事项</h3><ul><li><strong>不触发重渲染</strong>：修改 <code>ref.current</code> 不会触发组件重渲染</li><li><strong>更新时机</strong>：不要在渲染期间修改 ref，应在副作用或事件处理器中修改</li><li><strong>类型安全</strong>：在 TypeScript 中注意 ref 的类型定义和 null 检查</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 类型安全的 ref 使用</span><br><span class="hljs-keyword">const</span> inputRef = useRef&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;(<span class="hljs-literal">null</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">focusInput</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-comment">// 需要进行 null 检查</span><br>  <span class="hljs-keyword">if</span> (inputRef.<span class="hljs-property">current</span>) &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><ol><li><p><strong>useEffect vs useLayoutEffect</strong>：</p><ul><li>优先使用 <code>useEffect</code>，仅在需要同步 DOM 操作时使用 <code>useLayoutEffect</code></li><li>理解执行时机差异，选择合适的 Hook 避免性能问题</li></ul></li><li><p><strong>useRef vs createRef</strong>：</p><ul><li>函数组件必须使用 <code>useRef</code>，类组件使用 <code>createRef</code></li><li><code>useRef</code> 保证对象一致性，避免重渲染导致的引用丢失</li></ul></li><li><p><strong>最佳实践</strong>：</p><ul><li>遵循 React 生命周期规则，在合适的时机更新 ref</li><li>注意类型安全和 null 检查</li><li>理解每个 Hook 的特性，选择最适合的工具</li></ul></li></ol><p>通过这次问题排查和学习，不仅解决了引导弹窗的定位问题，更重要的是加深了对 React Hooks 机制的理解，为后续开发提供了坚实的基础。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 GitHub Pages + Hexo 快速搭建个人博客</title>
    <link href="/2023/06/25/hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/06/25/hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>拥有一个自己的博客站点是件非常酷炫的事情，利用 <strong>GitHub Pages</strong> 和 <strong>Hexo</strong> 可轻松实现这个目标。</p><blockquote><p>ps：GitLab 其实也支持 Pages 功能，但公司内网的该功能域名和证书支持均被禁用，实用性较低，故不展开。</p></blockquote><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-GitHub-创建个人仓库"><a href="#1-GitHub-创建个人仓库" class="headerlink" title="1. GitHub 创建个人仓库"></a>1. GitHub 创建个人仓库</h3><ol><li>登录 GitHub 账号，点击页面右上角的 <strong>New repository</strong> 创建新仓库。</li><li>仓库名必须为固定格式：<code>用户名.github.io</code>（将“用户名”替换为你的 GitHub 账号名称）。<ul><li>示例：若 GitHub 账号名为 <code>zuiai-kjl</code>，则仓库名应为 <code>zuiai-kjl.github.io</code>。</li></ul></li></ol><h3 id="2-安装必要工具"><a href="#2-安装必要工具" class="headerlink" title="2. 安装必要工具"></a>2. 安装必要工具</h3><p>以下工具为搭建博客的基础依赖，需提前安装完成：</p><ul><li><strong>Git</strong>：版本控制工具，用于后续代码提交与部署。（默认大家已安装，此处略过详细步骤）</li><li><strong>Node.js</strong>：Hexo 基于 Node.js 运行，<strong>最低要求 v18 版本</strong>，推荐安装最新稳定版（可通过 <a href="https://nodejs.org/">Node.js 官网</a> 下载）。</li><li><strong>Hexo</strong>：博客框架，通过 npm 命令全局安装，终端执行以下命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li></ul><h2 id="二、初始化-Hexo-博客"><a href="#二、初始化-Hexo-博客" class="headerlink" title="二、初始化 Hexo 博客"></a>二、初始化 Hexo 博客</h2><p>所有必备工具安装完成后，执行以下命令初始化博客项目：</p><ol><li>初始化博客文件夹（将 <code>&lt;folder&gt;</code> 替换为你想存放博客的文件夹名称，如 <code>my-blog</code>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt;<br></code></pre></td></tr></table></figure></li><li>进入初始化好的博客目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &lt;folder&gt;<br></code></pre></td></tr></table></figure></li><li>安装项目依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li></ol><p>执行完成后，你将得到一个 Hexo 博客的基础雏形，包含默认的目录结构和示例文章。</p><h2 id="三、写作：发布第一篇文章"><a href="#三、写作：发布第一篇文章" class="headerlink" title="三、写作：发布第一篇文章"></a>三、写作：发布第一篇文章</h2><h3 id="1-创建新文章"><a href="#1-创建新文章" class="headerlink" title="1. 创建新文章"></a>1. 创建新文章</h3><p>在博客根目录执行以下命令，创建一篇新的 Markdown 格式文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;this is title&quot;</span><br></code></pre></td></tr></table></figure><ul><li>该命令会在博客目录的 <code>source/_posts</code> 文件夹下生成一个名为 <code>this is title.md</code> 的文件。</li></ul><h3 id="2-编辑文章"><a href="#2-编辑文章" class="headerlink" title="2. 编辑文章"></a>2. 编辑文章</h3><ul><li>推荐使用 <strong>VS Code</strong> 或其他支持 Markdown 的编辑器（如 Typora）打开 <code>source/_posts/this is title.md</code> 文件进行编辑。</li><li>编辑器通常支持 Markdown 实时预览，可直观查看文章排版效果。</li></ul><h3 id="3-本地预览"><a href="#3-本地预览" class="headerlink" title="3. 本地预览"></a>3. 本地预览</h3><p>文章编辑完成后，在博客根目录执行以下两条命令，即可在本地浏览器预览博客效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成静态网页文件</span><br>hexo g<br><span class="hljs-comment"># 启动本地服务器</span><br>hexo s<br></code></pre></td></tr></table></figure><ul><li>执行 <code>hexo s</code> 后，终端会提示访问地址（默认是 <code>http://localhost:4000</code>），打开浏览器输入该地址即可查看新增的博文。</li></ul><h2 id="四、资源管理（以图片为例）"><a href="#四、资源管理（以图片为例）" class="headerlink" title="四、资源管理（以图片为例）"></a>四、资源管理（以图片为例）</h2><p>博客中常需插入图片，根据图片数量和大小，推荐两种资源管理方式：</p><h3 id="1-单篇文章独立资源文件夹（适合少量图片）"><a href="#1-单篇文章独立资源文件夹（适合少量图片）" class="headerlink" title="1. 单篇文章独立资源文件夹（适合少量图片）"></a>1. 单篇文章独立资源文件夹（适合少量图片）</h3><ul><li><strong>配置方式</strong>：在博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>）中，将 <code>post_asset_folder</code> 设为 <code>true</code>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><strong>效果</strong>：之后使用 <code>hexo new &quot;文章标题&quot;</code> 创建文章时，会在 <code>source/_posts</code> 下同时生成一个与文章同名的文件夹（如 <code>this is title</code> 文件夹）。</li><li><strong>使用</strong>：将该文章所需的图片放入同名文件夹，在 Markdown 中通过相对路径引用（如 <code>![图片描述](./this is title/图片名.jpg)</code>）。</li></ul><h3 id="2-图床（适合大量图片）"><a href="#2-图床（适合大量图片）" class="headerlink" title="2. 图床（适合大量图片）"></a>2. 图床（适合大量图片）</h3><p>若文章包含大量图片，直接放在 GitHub 会导致网页加载缓慢（尤其国内访问 GitHub 不稳定），此时推荐使用 <strong>图床</strong> 存储图片：</p><ul><li><strong>原理</strong>：将图片上传到图床平台，获取图片的外部链接，再在 Markdown 中通过外部链接引用图片（语法：<code>![图片描述](图片外部链接)</code>）。</li><li><strong>推荐免费图床</strong>：<ul><li><a href="https://www.superbed.cn/#pricing">Superbed</a></li><li><a href="https://imgtg.com/">imgtg</a></li><li><a href="https://chromewebstore.google.com/detail/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/pinjkilghdfhnkibhcangnpmcpdpmehk">微博图床（Chrome 插件）</a>（国内用户常用，需配合 Chrome 浏览器使用）</li></ul></li></ul><h2 id="五、部署：将博客发布到-GitHub-Pages"><a href="#五、部署：将博客发布到-GitHub-Pages" class="headerlink" title="五、部署：将博客发布到 GitHub Pages"></a>五、部署：将博客发布到 GitHub Pages</h2><p>本地预览无误后，需将博客部署到 GitHub Pages，让其他人可通过互联网访问你的博客。以下介绍 <strong>快速部署（推送生成好的网页文件）</strong> 方式（推荐新手使用）。</p><h3 id="1-配置部署信息"><a href="#1-配置部署信息" class="headerlink" title="1. 配置部署信息"></a>1. 配置部署信息</h3><ol><li><p>打开博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>），翻到文件末尾的 <code>deploy</code> 配置项，修改为以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">你的</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">仓库完整路径（需带</span> <span class="hljs-string">.git</span> <span class="hljs-string">后缀）</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署到仓库的 master 分支（部分新仓库默认分支为 main，需对应修改）</span><br></code></pre></td></tr></table></figure><ul><li>示例：若仓库地址为 <code>https://github.com/zuiai-kjl/zuiai-kjl.github.io</code>，则 <code>repo</code> 应填写 <code>https://github.com/zuiai-kjl/zuiai-kjl.github.io.git</code>。</li></ul></li><li><p>安装 Git 部署插件：在博客根目录执行以下命令，用于支持 Hexo 向 GitHub 推送文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-执行部署命令"><a href="#2-执行部署命令" class="headerlink" title="2. 执行部署命令"></a>2. 执行部署命令</h3><p>在博客根目录依次执行以下三条命令，完成部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理本地生成的旧静态文件（避免缓存问题）</span><br>hexo clean<br><span class="hljs-comment"># 重新生成最新的静态网页文件</span><br>hexo generate<br><span class="hljs-comment"># 部署到 GitHub Pages</span><br>hexo deploy<br></code></pre></td></tr></table></figure><ul><li>部署完成后，可进入 GitHub 仓库的 <strong>Actions</strong> 页面查看部署进度（若显示绿色对勾，则部署成功）。</li><li>访问博客：部署成功后，等待 1-2 分钟，在浏览器中输入 <code>https://用户名.github.io</code>（如 <code>https://zuiai-kjl.github.io</code>），即可访问你的公开博客。</li></ul><blockquote><p>ps：通过 <code>hexo deploy</code> 部署到 GitHub 的文件是 <strong>Markdown 转化后的静态 HTML 文件</strong>，而非原始的 Markdown 源码。若本地文件丢失或需在其他电脑修改博客，需额外备份源码（可通过 Git 单独管理源码分支）。</p></blockquote><h2 id="六、美化配置：更换-Hexo-主题"><a href="#六、美化配置：更换-Hexo-主题" class="headerlink" title="六、美化配置：更换 Hexo 主题"></a>六、美化配置：更换 Hexo 主题</h2><p>Hexo 拥有丰富的开源主题，可通过更换主题快速美化博客。以下以 <strong>Fluid 主题</strong> 为例（颜值高、可配置项丰富、文档齐全）。</p><h3 id="1-安装-Fluid-主题"><a href="#1-安装-Fluid-主题" class="headerlink" title="1. 安装 Fluid 主题"></a>1. 安装 Fluid 主题</h3><p>在博客根目录执行以下命令，通过 npm 安装 Fluid 主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><h3 id="2-启用主题"><a href="#2-启用主题" class="headerlink" title="2. 启用主题"></a>2. 启用主题</h3><ol><li><p>打开博客根目录的 <strong>站点配置文件</strong>（<code>_config.yml</code>），修改 <code>theme</code> 和 <code>language</code> 配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定使用 Fluid 主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定主题显示语言为中文（可按需修改为 en 等）</span><br></code></pre></td></tr></table></figure></li><li><p>复制主题配置文件：</p><ul><li>进入 <code>node_modules/hexo-theme-fluid</code> 目录，找到主题自带的 <code>_config.yml</code> 文件（该文件包含主题的所有配置项）。</li><li>在博客根目录新建一个名为 <code>_config.fluid.yml</code> 的文件，将上述 <code>_config.yml</code> 的内容复制进去（后续修改主题配置只需编辑 <code>_config.fluid.yml</code>，避免直接修改主题源码目录的文件，方便主题更新）。</li></ul></li></ol><h3 id="3-预览主题效果"><a href="#3-预览主题效果" class="headerlink" title="3. 预览主题效果"></a>3. 预览主题效果</h3><p>在博客根目录执行以下命令，本地预览美化后的博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><h3 id="4-自定义主题"><a href="#4-自定义主题" class="headerlink" title="4. 自定义主题"></a>4. 自定义主题</h3><p>Fluid 主题支持丰富的自定义配置（如导航栏、侧边栏、评论功能等），可参考官方文档进行配置：</p><ul><li><a href="https://hexo.fluid-dev.com/docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Fluid 主题官方文档</a></li></ul><p>更多 Hexo 主题可在 <a href="https://hexo.io/themes/">Hexo 官方主题库</a> 浏览选择。</p><h2 id="七、写在最后"><a href="#七、写在最后" class="headerlink" title="七、写在最后"></a>七、写在最后</h2><ul><li>示例博客：笔者花费小半天搭建的博客地址 → <a href="https://renjie-l.github.io/">https://renjie-l.github.io/</a></li><li>参考文档：<ul><li><a href="https://docs.github.com/cn/pages/quickstart">GitHub Pages 快速入门</a></li><li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档（中文）</a></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 新特性</title>
    <link href="/2022/05/18/c++141720%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2022/05/18/c++141720%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><h2 id="C-11-的新特性有哪些"><a href="#C-11-的新特性有哪些" class="headerlink" title="C++11 的新特性有哪些"></a>C++11 的新特性有哪些</h2><p>C++新特性主要包括包含语法改进和标准库扩充两个方面，主要包括以下11点：</p><ol><li>统一的初始化方法<br>C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i_arr[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br><span class="hljs-type">long</span> l_arr[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span> &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125; a = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br></code></pre></td></tr></table></figure><p><strong>但是</strong> 这种初始化方式的<strong>适用性非常狭窄</strong>，只有上面提到的这两种数据类型可以使用初始化列表。在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，实例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">const</span> Foo &amp;);<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">123</span>)</span></span>;<br>    Foo a2 = <span class="hljs-number">123</span>;  <span class="hljs-comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span><br>    Foo a3 = &#123; <span class="hljs-number">123</span> &#125;;<br>    Foo a4 &#123; <span class="hljs-number">123</span> &#125;;<br>    <span class="hljs-type">int</span> a5 = &#123; <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-type">int</span> a6 &#123; <span class="hljs-number">3</span> &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p><ol start="2"><li><p>成员变量默认初始化<br>构建一个类的对象不需要用构造函数初始化成员变量。</p></li><li><p>auto关键</p></li></ol><p>用于定义变量，编译器可以自动判断的类型（前提：定义一个变量时对其进行初始化）。</p><ol start="4"><li>decltype 求表达式的类型</li></ol><p>decltype 是 C++11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。</p><p>(1)为什么要有decltype</p><p>因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p><p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> varname = value;<br><span class="hljs-keyword">decltype</span>(exp) varname = value;<br></code></pre></td></tr></table></figure><p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p><p>auto 根据”&#x3D;“右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟”&#x3D;“右边的 value 没有关系。</p><p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</p><ol start="5"><li>智能指针 shared_ptr</li></ol><p>和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><ol start="6"><li>空指针 nullptr（原来NULL）</li></ol><p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。值得一提的是，nullptr 可以被隐式转换成任意的指针类型。</p><p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int_、char_ 以及 double* 指针类型。</p><ol start="7"><li><p>基于范围的for循环</p></li><li><p>右值引用和move语义</p></li></ol><ul><li>右值引用</li></ul><p>C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = num; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure><p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98&#x2F;03 标准中的引用又称为左值引用。</p><p>注意，虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b = num;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;c = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ul><li>move语义</li></ul><p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。基于 move() 函数特殊的功能，其常用于实现移动语义。</p><ol start="9"><li>无序容器（哈希表）<br>用法和功能同map一模一样，区别在于哈希表的效率更高。<br>(1) 无序容器具有以下 2 个特点：<br>a. 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，<br>b. 和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。<br>(2) 和关联式容器一样，无序容器只是一类容器的统称，其包含有 4 个具体容器，分别为 unordered_map、unordered_multimap、unordered_set 以及 unordered_multiset。功能如下表：</li></ol><table><thead><tr><th>无序容器</th><th>功能</th></tr></thead><tbody><tr><td>unordered_map</td><td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td></tr><tr><td>unordered_multimap</td><td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td></tr><tr><td>unordered_set</td><td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td></tr></tbody></table><p>| unordered_multiset | 和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。 |</p><ol start="10"><li><p>正则表达式<br>可以认为正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串。</p></li><li><p>Lambda匿名函数<br>所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p></li></ol><h2 id="C-中智能指针和指针的区别是什么？"><a href="#C-中智能指针和指针的区别是什么？" class="headerlink" title="C++ 中智能指针和指针的区别是什么？"></a>C++ 中智能指针和指针的区别是什么？</h2><p><strong>参考回答</strong></p><ol><li>智能指针</li></ol><p>如果在程序中使用new从堆（自由存储区）分配内存，等到不需要时，应使用delete将其释放。C++引用了智能指针auto_ptr，以帮助自动完成这个过程。随后的编程体验（尤其是使用STL）表明，需要有更精致的机制。基于程序员的编程体验和BOOST库提供的解决方案，C++11摒弃了auto_ptr，并新增了三种智能指针：unique_ptr、shared_ptr和weak_ptr。所有新增的智能指针都能与STL容器和移动语义协同工作。</p><ol start="2"><li>指针</li></ol><p>C 语言规定所有变量在使用前必须先定义，指定其类型，并按此分配内存单元。指针变量不同于整型变量和其他类型的变量，它是专门用来存放地址的，所以必须将它定义为“指针类型”。</p><ol start="3"><li>智能指针和普通指针的区别</li></ol><p><strong>智能指针和普通指针的区别</strong>在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。</p><h2 id="C-中的智能指针有哪些？分别解决的问题以及区别？"><a href="#C-中的智能指针有哪些？分别解决的问题以及区别？" class="headerlink" title="C++中的智能指针有哪些？分别解决的问题以及区别？"></a>C++中的智能指针有哪些？分别解决的问题以及区别？</h2><ol><li><p>C++中的智能指针有4种，分别为：<strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong>，其中auto_ptr被C++11弃用。</p></li><li><p>使用智能指针的原因</p></li></ol><p>申请的空间（即new出来的空间），在使用结束时，需要delete掉，否则会形成内存碎片。在程序运行期间，new出来的对象，在析构函数中delete掉，但是这种方法不能解决所有问题，因为有时候new发生在某个全局函数里面，该方法会给程序员造成精神负担。<strong>此时，智能指针就派上了用场。</strong> 使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针的作用原理就是在函数结束时自动释放内存空间，避免了手动释放内存空间。</p><ol start="3"><li>四种指针分别解决的问题以及各自特性如下：</li></ol><p>（1）auto_ptr（C++98的方案，C++11已经弃用）</p><p>采用所有权模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p2;<br>p2=p1; <span class="hljs-comment">//auto_ptr不会报错</span><br></code></pre></td></tr></table></figure><p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题。</p><p>（2）unique_ptr（替换auto_ptr）</p><p>unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露，例如，以new创建对象后因为发生异常而忘记调用delete时的情形特别有用。</p><p>采用所有权模式，和上面例子一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string(<span class="hljs-string">&quot;I reigned loney as a cloud.&quot;</span>))</span></span>;<br>auto_ptr&lt;string&gt; p4;<br>p4=p3; <span class="hljs-comment">//此时不会报错</span><br></code></pre></td></tr></table></figure><p>编译器认为P4&#x3D;P3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。 另外unique_ptr还有更聪明的地方：当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;string&gt; <span class="hljs-title">pu1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string (<span class="hljs-string">&quot;hello world&quot;</span>))</span></span>;<br>unique_ptr&lt;string&gt; pu2;<br>pu2 = pu1;                                      <span class="hljs-comment">// #1 not allowed</span><br>unique_ptr&lt;string&gt; pu3;<br>pu3 = <span class="hljs-built_in">unique_ptr</span>&lt;string&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (<span class="hljs-string">&quot;You&quot;</span>));   <span class="hljs-comment">// #2 allowed</span><br></code></pre></td></tr></table></figure><p>其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</p><p><strong>注意：</strong> 如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。</p><p>（3）shared_ptr（非常好使）</p><p>shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</p><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</p><p><strong>成员函数：</strong></p><p><strong>use_count</strong> 返回引用计数的个数</p><p><strong>unique</strong> 返回是否是独占所有权( use_count 为 1)</p><p><strong>swap</strong> 交换两个 shared_ptr 对象(即交换所拥有的对象)</p><p><strong>reset</strong> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</p><p><strong>get</strong> 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</p><p>（4）weak_ptr</p><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;B&gt; pb_;<br>    ~<span class="hljs-built_in">A</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;A delete\n&quot;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;A&gt; pa_;<br>    ~<span class="hljs-built_in">B</span>()<br>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;B delete\n&quot;</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">shared_ptr&lt;B&gt; <span class="hljs-title">pb</span><span class="hljs-params">(<span class="hljs-keyword">new</span> B())</span></span>;<br>    <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">pa</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>    pb-&gt;pa_ = pa;<br>    pa-&gt;pb_ = pb;<br>    cout&lt;&lt;pb.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>    cout&lt;&lt;pa.<span class="hljs-built_in">use_count</span>()&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">fun</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。</p><p><strong>注意</strong>：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa-&gt;pb_-&gt;print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr，如：shared_ptr p &#x3D; pa-&gt;pb_.lock(); p-&gt;print();</p><h1 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h1><p>相对于C++11，C++14的改动可谓非常mini了，主要的改动一句话便是：扩大自动类型推断的应用范围。</p><h2 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h2><p>C++14对函数返回类型推导规则做了优化，先看一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">4</span>) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用C++11编译：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~/test$ g++ test.cc -std=c+<span class="hljs-number">+11</span><br>test.cc:<span class="hljs-number">5</span>:<span class="hljs-number">16</span>: error: ‘func’ function uses ‘<span class="hljs-keyword">auto</span>’ type specifier without trailing <span class="hljs-keyword">return</span> type<br> <span class="hljs-keyword">auto</span> <span class="hljs-built_in">func</span>(<span class="hljs-type">int</span> i) &#123;<br>                ^<br>test.cc:<span class="hljs-number">5</span>:<span class="hljs-number">16</span>: note: deduced <span class="hljs-keyword">return</span> type only available with -std=c+<span class="hljs-number">+14</span> <span class="hljs-keyword">or</span> -std=gnu+<span class="hljs-number">+14</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2022/05/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/09/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP体系结构"><a href="#TCP-IP体系结构" class="headerlink" title="TCP&#x2F;IP体系结构"></a>TCP&#x2F;IP体系结构</h1><p>每一层的封装格式：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img"></p><h1 id="键入网址到网页显示，期间发生了什么？"><a href="#键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h1><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg" alt="简单的网络模型"></p><ul><li><p><strong>HTTP</strong></p><p>首先浏览器做的第一步工作就是要对 URL 进行解析，从而生成发送给 Web 服务器的请求信息。</p><p>对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p></li><li><p><strong>DNS</strong></p><p>域名解析过程，本机如何干预域名解析</p><p>（1）在浏览器中输入<code>https://renjie-l.github.io/</code>域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。</p><p>（2）如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。</p><p>（3）如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP&#x2F;IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。</p><p>（4）如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。</p><p>（5）如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找域服务器，重复上面的动作，进行查询，直至找到<code>https://renjie-l.github.io/</code>主机。</p><p>（6）如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p><p>从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p></li><li><p><strong>协议栈</strong></p></li></ul><p>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img"></p><ul><li><strong>出口 —— 网卡</strong></li><li><strong>交换机</strong></li><li><strong>路由器</strong></li></ul><h1 id="静态路由和动态路由"><a href="#静态路由和动态路由" class="headerlink" title="静态路由和动态路由"></a>静态路由和动态路由</h1><ol><li><p>静态路由是由系统管理员设计与构建的路由表规定的路由。适用于网关数量有限的场合，且网络拓朴结构不经常变化的网络。其缺点是不能动态地适用网络状况的变化，当网络状况变化后必须由网络管理员修改路由表。</p></li><li><p>动态路由是由路由选择协议而动态构建的，路由协议之间通过交换各自所拥有的路由信息实时更新路由表的内容。动态路由可以自动学习网络的拓朴结构，并更新路由表。其缺点是路由广播更新信息将占据大量的网络带宽。</p></li></ol><h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><ol><li>路由可分为静态&amp;动态路由。静态路由由管理员手动维护；动态路由由路由协议自动维护。</li></ol><p>路由选择算法的必要步骤：</p><p>1）向其它路由器传递路由信息；</p><p>2）接收其它路由器的路由信息；</p><p>3）根据收到的路由信息计算出到每个目的网络的最优路径，并由此生成路由选择表；</p><p>4）根据网络拓扑的变化及时的做出反应，调整路由生成新的路由选择表，同时把拓扑变化以路由 信息的形式向其它路由器宣告。</p><p>两种主要算法：距离向量法（Distance Vector Routing）和链路状态算法（Link-State Routing）。</p><h1 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h1><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p><p>DNS劫持症状：在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p><h1 id="MAC地址和IP地址"><a href="#MAC地址和IP地址" class="headerlink" title="MAC地址和IP地址"></a>MAC地址和IP地址</h1><ol><li><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。而MAC地址，指的是物理地址，用来定义网络设备的位置。</p></li><li><p>IP地址的分配是<strong>根据网络的拓扑结构</strong>，而不是根据谁制造了网络设置。若将高效的路由选择方案建立在设备制造商的基础上而不是网络所处的拓朴位置基础上，这种方案是不可行的。</p></li><li><p>当存在一个附加层的地址寻址时，设备更易于移动和维修。例如，如果一个以太网卡坏了，可以被更换，而无须取得一个新的IP地址。如果一个IP主机从一个网络移到另一个网络，可以给它一个新的IP地址，而无须换一个新的网卡。</p></li><li><p>无论是局域网，还是广域网中的计算机之间的通信，最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由<strong>ARP</strong>（Address Resolution Protocol：地址解析协议）负责<strong>将IP地址映射到MAC地址上来完成的</strong>。</p></li></ol><h1 id="TCP-三次握手和四次挥手的过程"><a href="#TCP-三次握手和四次挥手的过程" class="headerlink" title="TCP 三次握手和四次挥手的过程"></a>TCP 三次握手和四次挥手的过程</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="https://git.poker/RenJie-L/PicHub/blob/master/20220814/image.7k2iy086q400.png?raw=true" alt="image"></p><p>1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq&#x3D;x），请求建立连接，等待确认</p><p>2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK&#x3D;x+1）确认收到，同时发送一个SYN包（seq&#x3D;y）给客户端</p><p>3）第三次握手：客户端收到SYN+ACK包，再回一个ACK包（ACK&#x3D;y+1）告诉服务端已经收到</p><p>4）三次握手完成，成功建立连接，开始传输数据</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://git.poker/RenJie-L/PicHub/blob/master/20220814/image.6s40z8i8x3k0.png?raw=true" alt="image"><br>1）客户端发送FIN包（FIN&#x3D;1）给服务端，告诉它自己的数据已经发送完毕，请求终止连接，此时客户端不发送数据，但还能接收数据</p><p>2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了，此时还没有断开socket连接，而是等待剩下的数据传输完毕</p><p>3）服务端等待数据传输完毕后，向客户端发送FIN包，表明可以断开连接</p><p>4）客户端收到后，回一个ACK包表明确认收到，等待一段时间，确保服务端不再有数据发过来，然后彻底断开连接</p><h1 id="TCP-2次握手行不行？为什么要3次"><a href="#TCP-2次握手行不行？为什么要3次" class="headerlink" title="TCP 2次握手行不行？为什么要3次"></a>TCP 2次握手行不行？为什么要3次</h1><ol><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p></li><li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p></li></ol><h1 id="如果三次握手时候每次握手信息对方没收到会怎么样"><a href="#如果三次握手时候每次握手信息对方没收到会怎么样" class="headerlink" title="如果三次握手时候每次握手信息对方没收到会怎么样"></a>如果三次握手时候每次握手信息对方没收到会怎么样</h1><ol><li><p>如果第一次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传</p></li><li><p>如果第二次握手消息丢失，那么请求方不会得到ack消息，超时后进行重传</p></li><li><p>如果第三次握手消息丢失，那么Server 端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便Client重新发送ACK包。而Server重发SYN+ACK包的次数，可以设置&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_synack_retries修改，默认值为5.如果重发指定次数之后，仍然未收到 client 的ACK应答，那么一段时间后，Server自动关闭这个连接。</p></li></ol><p>client 一般是通过 connect() 函数来连接服务器的，而connect()是在 TCP的三次握手的第二次握手完成后就成功返回值。也就是说 client 在接收到 SYN+ACK包，它的TCP连接状态就为 established （已连接），表示该连接已经建立。那么如果 第三次握手中的ACK包丢失的情况下，Client 向 server端发送数据，Server端将以 RST包响应，方能感知到Server的错误。</p><h1 id="TCP-和-UDP-的区别，它们的头部结构是什么样的"><a href="#TCP-和-UDP-的区别，它们的头部结构是什么样的" class="headerlink" title="TCP 和 UDP 的区别，它们的头部结构是什么样的"></a>TCP 和 UDP 的区别，它们的头部结构是什么样的</h1><ol><li>TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的</li></ol><p>TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。</p><p>TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。</p><p>TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率</p><p>TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。</p><p>TCP面向的是字节流的服务，UDP面向的是报文的服务。</p><p>TCP头部结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*TCP头定义，共20个字节*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_TCP_HEADER</span> &#123;<br>    <span class="hljs-type">short</span> m_sSourPort;        　　　　　　<span class="hljs-comment">// 源端口号16bit</span><br>    <span class="hljs-type">short</span> m_sDestPort;       　　　　　　 <span class="hljs-comment">// 目的端口号16bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_uiSequNum;       　　<span class="hljs-comment">// 序列号32bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> m_uiAcknowledgeNum;  <span class="hljs-comment">// 确认号32bit</span><br>    <span class="hljs-type">short</span> m_sHeaderLenAndFlag;      　　<span class="hljs-comment">// 前4位：TCP头长度；中6位：保留；后6位：标志位</span><br>    <span class="hljs-type">short</span> m_sWindowSize;       　　　　　<span class="hljs-comment">// 窗口大小16bit</span><br>    <span class="hljs-type">short</span> m_sCheckSum;        　　　　　 <span class="hljs-comment">// 检验和16bit</span><br>    <span class="hljs-type">short</span> m_surgentPointer;      　　　　 <span class="hljs-comment">// 紧急数据偏移量16bit</span><br>&#125;__attribute__((packed))TCP_HEADER, *PTCP_HEADER;<br></code></pre></td></tr></table></figure><p>UDP头部结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*UDP头定义，共8个字节*/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_UDP_HEADER</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_usSourPort;    　　　<span class="hljs-comment">// 源端口号16bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_usDestPort;    　　　<span class="hljs-comment">// 目的端口号16bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_usLength;    　　　　<span class="hljs-comment">// 数据包长度16bit</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> m_usCheckSum;    　　<span class="hljs-comment">// 校验和16bit</span><br>&#125;__attribute__((packed))UDP_HEADER, *PUDP_HEADER;<br><br></code></pre></td></tr></table></figure><h1 id="TCP-慢启动"><a href="#TCP-慢启动" class="headerlink" title="TCP 慢启动"></a>TCP 慢启动</h1><p><strong>慢启动</strong>（Slow Start），是传输控制协议（TCP）使用的一种阻塞控制机制。慢启动也叫做指数增长期。慢启动是指每次TCP接收窗口收到确认时都会增长。增加的大小就是已确认段的数目。这种情况一直保持到要么没有收到一些段，要么窗口大小到达预先定义的阈值。如果发生丢失事件，TCP就认为这是网络阻塞，就会采取措施减轻网络拥挤。一旦发生丢失事件或者到达阈值，TCP就会进入线性增长阶段。这时，每经过一个RTT窗口增长一个段。</p><h1 id="TCP-如何保证有序"><a href="#TCP-如何保证有序" class="headerlink" title="TCP 如何保证有序"></a>TCP 如何保证有序</h1><ul><li><p>主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p></li><li><p>具体步骤如下：</p></li></ul><p>（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；</p><p>（2）并为每个已发送的数据包启动一个超时定时器；</p><p>（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;</p><p>（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。</p><p>（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。</p><h1 id="TCP-可靠性保证"><a href="#TCP-可靠性保证" class="headerlink" title="TCP 可靠性保证"></a>TCP 可靠性保证</h1><p>TCP主要提供了<strong>检验和、序列号&#x2F;确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p><h2 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h2><ul><li>通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932425713/8B3A0FE3661628DCF27F95BC7BF77726" alt="图片标题"></li></ul><h2 id="序列号-确认应答"><a href="#序列号-确认应答" class="headerlink" title="序列号&#x2F;确认应答"></a>序列号&#x2F;确认应答</h2><ul><li><p>这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。</p></li><li><p>上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整性。<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932453593/D09DA1AB1CD3F916F8E8345CE7D201F6" alt="图片标题"></p></li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><ul><li><p>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？</p></li><li><p>我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。</p></li><li><p>从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932486856/A4541736F158A2B080AF4649517CF437" alt="图片标题"></p></li><li><p>但是在重发的过程中，假如一个包经过多次的重发也没有收到对端的确认包，那么就会认为接收端异常，强制关闭连接。并且通知应用通信异常强行终止。</p></li></ul><h2 id="最大消息长度"><a href="#最大消息长度" class="headerlink" title="最大消息长度"></a>最大消息长度</h2><ul><li>在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932502076/7FC42AB847F62CFF688B47D2767983D2" alt="图片标题"></li></ul><h2 id="滑动窗口控制"><a href="#滑动窗口控制" class="headerlink" title="滑动窗口控制"></a>滑动窗口控制</h2><ul><li><p>我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932523218/C2C50AD3D705E50C85E7E5A389FA1C5A" alt="图片标题"></p></li><li><p>窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。这个机制的实现就是使用了大量的缓冲区，通过对多个段进行确认应答的功能。通过下一次的确认包可以判断接收端是否已经接收到了数据，如果已经接收了就从缓冲区里面删除数据。</p></li><li><p>在窗口之外的数据就是还未发送的和对端已经收到的数据。那么发送端是怎么样判断接收端有没有接收到数据呢？或者怎么知道需要重发的数据有哪些呢？通过下面这个图就知道了。<br><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932544426/82F70852E06C3C8DB2B4CE34BFF20DAF" alt="图片标题"></p></li><li><p>如上图，接收端在没有收到自己所期望的序列号数据之前，会对之前的数据进行重复确认。发送端在收到某个应答包之后，又连续3次收到同样的应答包，则数据已经丢失了，需要重发。</p></li></ul><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ul><li><p>窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</p></li><li><p>发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。</p></li><li><p>慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加至拥塞窗口；线性增长达到网络拥塞时立即把拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。</p></li></ul><p><img src="https://uploadfiles.nowcoder.com/images/20210305/102124_1614932558168/E48D9C30838AC332D4E278C96DFEDDD0" alt="图片标题"></p><h1 id="TCP-的-TIME-WAIT，为什么需要有这个状态"><a href="#TCP-的-TIME-WAIT，为什么需要有这个状态" class="headerlink" title="TCP 的 TIME_WAIT，为什么需要有这个状态"></a>TCP 的 TIME_WAIT，为什么需要有这个状态</h1><ol><li>TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。</li></ol><p>对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。</p><p>这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。</p><ol start="2"><li>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</li></ol><h1 id="什么是-MSL，为什么客户端连接要等待2MSL的时间才能完全关闭"><a href="#什么是-MSL，为什么客户端连接要等待2MSL的时间才能完全关闭" class="headerlink" title="什么是 MSL，为什么客户端连接要等待2MSL的时间才能完全关闭"></a>什么是 MSL，为什么客户端连接要等待2MSL的时间才能完全关闭</h1><ol><li><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></li><li><p>为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。</p></li></ol><ul><li>两个理由：</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>积累</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix/Linux 下的 Pthreads 线程编程详解</title>
    <link href="/2022/01/09/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/01/09/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-Linux-下的-Pthreads-线程编程详解"><a href="#Unix-Linux-下的-Pthreads-线程编程详解" class="headerlink" title="Unix&#x2F;Linux 下的 Pthreads 线程编程详解"></a>Unix&#x2F;Linux 下的 Pthreads 线程编程详解</h1><p>在传统 Unix 模型中，进程是资源分配和调度的基本单位。当一个进程需要并发执行任务时，通常会通过 <code>fork()</code> 派生子进程处理，但这种方式存在<strong>开销大</strong>（内存映像拷贝、描述符复制）和<strong>通信复杂</strong>（需依赖 IPC 机制）的问题。线程（Thread）作为“轻量级进程”，可有效解决这些痛点——同一进程内的线程共享大部分资源（如代码段、数据段、打开文件），创建速度比进程快 10~100 倍，且线程间通信无需额外机制。</p><p>Linux 下的线程编程遵循 <strong>POSIX.1 标准</strong>，称为 <strong>Pthreads</strong>（POSIX Threads）。本文将从线程基础、核心操作、同步机制到线程属性，全面讲解 Pthreads 编程。</p><h2 id="一、Pthreads-基础：数据结构与核心函数"><a href="#一、Pthreads-基础：数据结构与核心函数" class="headerlink" title="一、Pthreads 基础：数据结构与核心函数"></a>一、Pthreads 基础：数据结构与核心函数</h2><p>Pthreads 提供了一套完整的 API 用于线程管理，核心可分为<strong>线程操作函数</strong>、<strong>同步函数</strong>和<strong>属性函数</strong>三类。</p><h3 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h3><table><thead><tr><th>数据结构</th><th>用途说明</th></tr></thead><tbody><tr><td><code>pthread_t</code></td><td>线程 ID（TID），用于标识一个线程。注意：它可能是结构体（而非单纯整数），与实现相关。</td></tr><tr><td><code>pthread_attr_t</code></td><td>线程属性结构体，用于设置线程的优先级、分离状态、栈大小等（默认属性可满足多数场景）。</td></tr><tr><td><code>pthread_mutex_t</code></td><td>互斥锁（Mutex），用于保证临界区资源的互斥访问。</td></tr><tr><td><code>pthread_cond_t</code></td><td>条件变量，用于线程间的“等待-通知”同步（需与互斥锁配合使用）。</td></tr><tr><td><code>pthread_key_t</code></td><td>线程特有数据（Thread-Specific Data, TSD）的键，用于存储线程私有数据。</td></tr><tr><td><code>sched_param</code></td><td>线程调度参数结构体，主要用于设置线程优先级。</td></tr></tbody></table><h3 id="2-线程操作核心函数"><a href="#2-线程操作核心函数" class="headerlink" title="2. 线程操作核心函数"></a>2. 线程操作核心函数</h3><p>线程的生命周期管理（创建、退出、等待、取消）依赖以下核心函数：</p><table><thead><tr><th>函数原型</th><th>功能说明</th></tr></thead><tbody><tr><td><code>int pthread_create(pthread_t *tidp, const pthread_attr_t *attr, void*(*start_rtn)(void*), void *arg)</code></td><td>创建新线程。成功返回 0，失败返回非 0 错误码（Pthreads 不设置 <code>errno</code>）。</td></tr><tr><td><code>void pthread_exit(void *rval_ptr)</code></td><td>终止当前线程，<code>rval_ptr</code> 为线程退出状态（需指向全局&#x2F;堆内存，避免栈地址）。</td></tr><tr><td><code>int pthread_join(pthread_t tid, void **rval_ptr)</code></td><td>阻塞当前线程，等待 <code>tid</code> 线程终止，并通过 <code>rval_ptr</code> 获取其退出状态。</td></tr><tr><td><code>int pthread_cancel(pthread_t tid)</code></td><td>向 <code>tid</code> 线程发送“取消请求”（线程可选择忽略或自定义处理），非阻塞调用。</td></tr><tr><td><code>pthread_t pthread_self(void)</code></td><td>获取<strong>当前线程</strong>的 TID。</td></tr><tr><td><code>int pthread_equal(pthread_t tid1, pthread_t tid2)</code></td><td>比较两个线程 ID 是否相等（因 <code>pthread_t</code> 可能非整数，不能直接用 <code>==</code>）。</td></tr><tr><td><code>int pthread_detach(pthread_t tid)</code></td><td>将 <code>tid</code> 线程设置为“分离状态”（退出后资源立即回收，无法用 <code>pthread_join</code> 等待）。</td></tr></tbody></table><h3 id="3-线程同步核心函数"><a href="#3-线程同步核心函数" class="headerlink" title="3. 线程同步核心函数"></a>3. 线程同步核心函数</h3><p>当多个线程访问共享资源时，需通过<strong>互斥锁</strong>、<strong>条件变量</strong>或<strong>读写锁</strong>保证同步，避免数据竞争。</p><h4 id="（1）互斥锁（Mutex）函数"><a href="#（1）互斥锁（Mutex）函数" class="headerlink" title="（1）互斥锁（Mutex）函数"></a>（1）互斥锁（Mutex）函数</h4><table><thead><tr><th>函数原型</th><th>功能说明</th></tr></thead><tbody><tr><td><code>int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)</code></td><td>初始化互斥锁（<code>attr</code> 为 <code>NULL</code> 时使用默认属性）。</td></tr><tr><td><code>int pthread_mutex_destroy(pthread_mutex_t *mutex)</code></td><td>销毁互斥锁（释放资源，需确保锁未被占用）。</td></tr><tr><td><code>int pthread_mutex_lock(pthread_mutex_t *mutex)</code></td><td>加锁：若锁已被占用，当前线程阻塞，直到锁被释放。</td></tr><tr><td><code>int pthread_mutex_trylock(pthread_mutex_t *mutex)</code></td><td>尝试加锁：若锁已被占用，立即返回 <code>EBUSY</code>（非阻塞），不阻塞线程。</td></tr><tr><td><code>int pthread_mutex_unlock(pthread_mutex_t *mutex)</code></td><td>解锁：释放互斥锁，需由加锁线程调用（否则行为未定义）。</td></tr></tbody></table><h4 id="（2）条件变量函数"><a href="#（2）条件变量函数" class="headerlink" title="（2）条件变量函数"></a>（2）条件变量函数</h4><table><thead><tr><th>函数原型</th><th>功能说明</th></tr></thead><tbody><tr><td><code>int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr)</code></td><td>初始化条件变量（<code>attr</code> 为 <code>NULL</code> 时使用默认属性）。</td></tr><tr><td><code>int pthread_cond_destroy(pthread_cond_t *cond)</code></td><td>销毁条件变量（需确保无线程在等待该变量）。</td></tr><tr><td><code>int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)</code></td><td>等待条件满足：解锁 <code>mutex</code> 并阻塞线程，被唤醒后重新加锁 <code>mutex</code>。</td></tr><tr><td><code>int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *timeout)</code></td><td>带超时的等待：超时后返回 <code>ETIMEDOUT</code>（<code>timeout</code> 为绝对时间）。</td></tr><tr><td><code>int pthread_cond_signal(pthread_cond_t *cond)</code></td><td>唤醒<strong>一个</strong>等待该条件变量的线程（若有多个，唤醒优先级最高的）。</td></tr><tr><td><code>int pthread_cond_broadcast(pthread_cond_t *cond)</code></td><td>唤醒<strong>所有</strong>等待该条件变量的线程。</td></tr></tbody></table><h4 id="（3）读写锁（Reader-Writer-Lock）函数"><a href="#（3）读写锁（Reader-Writer-Lock）函数" class="headerlink" title="（3）读写锁（Reader-Writer Lock）函数"></a>（3）读写锁（Reader-Writer Lock）函数</h4><p>读写锁适用于“读多写少”场景，允许多个线程同时读，但仅允许一个线程写（写操作独占）。</p><table><thead><tr><th>函数原型</th><th>功能说明</th></tr></thead><tbody><tr><td><code>int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr)</code></td><td>初始化读写锁。</td></tr><tr><td><code>int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)</code></td><td>销毁读写锁。</td></tr><tr><td><code>int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock)</code></td><td>加读锁：若无写锁占用，可多个线程同时加锁。</td></tr><tr><td><code>int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)</code></td><td>加写锁：若有读锁&#x2F;写锁占用，线程阻塞，直到锁释放。</td></tr><tr><td><code>int pthread_rwlock_unlock(pthread_rwlock_t *rwlock)</code></td><td>释放锁（读锁&#x2F;写锁通用）。</td></tr></tbody></table><h3 id="4-线程特有数据（TSD）函数"><a href="#4-线程特有数据（TSD）函数" class="headerlink" title="4. 线程特有数据（TSD）函数"></a>4. 线程特有数据（TSD）函数</h3><p>线程特有数据（TSD）允许每个线程拥有独立的私有数据（即使线程共享全局变量），通过 <code>pthread_key_t</code> 标识：</p><table><thead><tr><th>函数原型</th><th>功能说明</th></tr></thead><tbody><tr><td><code>int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))</code></td><td>创建 TSD 键，<code>destructor</code> 为数据销毁函数（线程退出时自动调用）。</td></tr><tr><td><code>int pthread_setspecific(pthread_key_t key, const void *value)</code></td><td>为当前线程的 <code>key</code> 绑定私有数据 <code>value</code>。</td></tr><tr><td><code>void *pthread_getspecific(pthread_key_t key)</code></td><td>获取当前线程 <code>key</code> 绑定的私有数据。</td></tr><tr><td><code>int pthread_key_delete(pthread_key_t key)</code></td><td>销毁 TSD 键（不调用销毁函数，需手动释放数据）。</td></tr></tbody></table><h2 id="二、Pthreads-核心概念与操作详解"><a href="#二、Pthreads-核心概念与操作详解" class="headerlink" title="二、Pthreads 核心概念与操作详解"></a>二、Pthreads 核心概念与操作详解</h2><h3 id="1-线程-ID-与身份判断"><a href="#1-线程-ID-与身份判断" class="headerlink" title="1. 线程 ID 与身份判断"></a>1. 线程 ID 与身份判断</h3><ul><li><strong><code>pthread_t</code> 的局限性</strong>：<code>pthread_t</code> 可能是结构体（如 Linux 下为 <code>unsigned long</code>，但标准未定义），因此不能直接用 <code>==</code> 比较两个线程 ID，必须使用 <code>pthread_equal(tid1, tid2)</code>。</li><li><strong>获取当前线程 ID</strong>：通过 <code>pthread_self()</code> 获取，示例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_func</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前线程 ID: %lu\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread_func, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待子线程结束</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-线程创建（pthread-create）"><a href="#2-线程创建（pthread-create）" class="headerlink" title="2. 线程创建（pthread_create）"></a>2. 线程创建（<code>pthread_create</code>）</h3><p><code>pthread_create</code> 是创建线程的核心函数，需重点理解其参数：</p><ul><li><code>tidp</code>：输出参数，指向存储新线程 ID 的 <code>pthread_t</code> 变量。</li><li><code>attr</code>：线程属性（如分离状态、优先级），<code>NULL</code> 表示使用默认属性。</li><li><code>start_rtn</code>：线程入口函数，类型为 <code>void* (*)(void*)</code>（接收 <code>void*</code> 参数，返回 <code>void*</code>）。</li><li><code>arg</code>：传递给 <code>start_rtn</code> 的参数，若需传递多个参数，需封装为结构体指针。</li></ul><h4 id="示例：创建线程并传递参数"><a href="#示例：创建线程并传递参数" class="headerlink" title="示例：创建线程并传递参数"></a>示例：创建线程并传递参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 线程入口函数：接收整数参数，打印并返回</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">print_num</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程接收的参数: %d\n&quot;</span>, num);<br>    <span class="hljs-built_in">free</span>(arg); <span class="hljs-comment">// 释放堆内存（避免内存泄漏）</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)<span class="hljs-number">100</span>; <span class="hljs-comment">// 线程退出状态（返回 100）</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> *arg = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 用堆内存传递参数（避免栈销毁问题）</span><br>    *arg = <span class="hljs-number">42</span>;<br><br>    <span class="hljs-comment">// 创建线程：默认属性，传递 arg 作为参数</span><br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, print_num, arg);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pthread_create failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 等待线程结束，并获取退出状态</span><br>    <span class="hljs-type">void</span> *rval_ptr;<br>    pthread_join(tid, &amp;rval_ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程退出状态: %d\n&quot;</span>, (<span class="hljs-type">int</span>)rval_ptr); <span class="hljs-comment">// 输出 100</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><strong>参数内存生命周期</strong>：<code>arg</code> 不能指向主线程的栈内存（若主线程先退出，栈内存会被释放，子线程访问时会触发野指针），需用<strong>全局变量</strong>或<strong>堆内存</strong>（<code>malloc</code> 分配）。</li><li><strong>线程执行顺序</strong>：无法假设主线程与子线程的执行顺序（取决于内核调度），需通过同步机制（如互斥锁、条件变量）控制。</li></ul><h3 id="3-线程退出与等待（pthread-exit-与-pthread-join）"><a href="#3-线程退出与等待（pthread-exit-与-pthread-join）" class="headerlink" title="3. 线程退出与等待（pthread_exit 与 pthread_join）"></a>3. 线程退出与等待（<code>pthread_exit</code> 与 <code>pthread_join</code>）</h3><p>线程退出有三种方式：</p><ol><li>线程入口函数正常返回（返回值即为退出状态）。</li><li>线程调用 <code>pthread_exit(rval_ptr)</code> 主动退出。</li><li>被其他线程调用 <code>pthread_cancel(tid)</code> 取消（需线程允许取消）。</li></ol><p><code>pthread_join</code> 类似进程的 <code>waitpid</code>，用于等待指定线程退出并回收资源：</p><ul><li>若线程已退出，<code>pthread_join</code> 会立即返回，并通过 <code>rval_ptr</code> 获取退出状态。</li><li>若线程未退出，<code>pthread_join</code> 会阻塞当前线程，直到目标线程退出。</li></ul><h4 id="示例：线程退出与等待"><a href="#示例：线程退出与等待" class="headerlink" title="示例：线程退出与等待"></a>示例：线程退出与等待</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_sleep</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sleep(<span class="hljs-number">2</span>); <span class="hljs-comment">// 模拟耗时操作</span><br>    pthread_exit((<span class="hljs-type">void</span> *)<span class="hljs-number">200</span>); <span class="hljs-comment">// 主动退出，返回 200</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread_sleep, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 等待线程退出，获取退出状态</span><br>    <span class="hljs-type">void</span> *rval_ptr;<br>    pthread_join(tid, &amp;rval_ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;子线程退出状态: %d\n&quot;</span>, (<span class="hljs-type">int</span>)rval_ptr); <span class="hljs-comment">// 输出 200</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程分离状态（Detached-State）"><a href="#线程分离状态（Detached-State）" class="headerlink" title="线程分离状态（Detached State）"></a>线程分离状态（Detached State）</h4><p>线程默认处于<strong>可结合状态</strong>（Joinable）：退出后资源（如退出状态）会保留，直到其他线程调用 <code>pthread_join</code> 回收。若线程设置为<strong>分离状态</strong>（Detached），退出后资源会立即被内核回收，无法用 <code>pthread_join</code> 等待。</p><p>设置分离状态的两种方式：</p><ol><li>创建线程时通过属性设置：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_attr_t</span> attr;<br>pthread_attr_init(&amp;attr);<br>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); <span class="hljs-comment">// 分离状态</span><br>pthread_create(&amp;tid, &amp;attr, thread_func, <span class="hljs-literal">NULL</span>);<br>pthread_attr_destroy(&amp;attr); <span class="hljs-comment">// 销毁属性对象</span><br></code></pre></td></tr></table></figure></li><li>线程创建后调用 <code>pthread_detach</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pthread_detach(tid); <span class="hljs-comment">// 将 tid 线程设为分离状态</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="4-线程取消（pthread-cancel）与清理函数"><a href="#4-线程取消（pthread-cancel）与清理函数" class="headerlink" title="4. 线程取消（pthread_cancel）与清理函数"></a>4. 线程取消（<code>pthread_cancel</code>）与清理函数</h3><p><code>pthread_cancel(tid)</code> 向目标线程发送“取消请求”，但目标线程需允许取消才能被终止：</p><ul><li>线程默认允许取消（可通过 <code>pthread_setcancelstate</code> 修改）。</li><li>取消请求并非立即生效，需等待线程进入“取消点”（如 <code>sleep</code>、<code>pthread_join</code>、<code>mutex</code> 操作等）。</li></ul><h4 id="线程清理函数（pthread-cleanup-push-pop）"><a href="#线程清理函数（pthread-cleanup-push-pop）" class="headerlink" title="线程清理函数（pthread_cleanup_push/pop）"></a>线程清理函数（<code>pthread_cleanup_push/pop</code>）</h4><p>线程被取消或调用 <code>pthread_exit</code> 时，需释放已占用的资源（如互斥锁、堆内存），可通过<strong>清理函数</strong>自动处理：</p><ul><li><code>pthread_cleanup_push(rtn, arg)</code>：将清理函数 <code>rtn</code> 压入栈（LIFO 顺序）。</li><li><code>pthread_cleanup_pop(execute)</code>：弹出栈顶清理函数，<code>execute=1</code> 时执行该函数，<code>execute=0</code> 时不执行。</li></ul><h4 id="示例：线程取消与清理"><a href="#示例：线程取消与清理" class="headerlink" title="示例：线程取消与清理"></a>示例：线程取消与清理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">// 清理函数：释放互斥锁</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup_mutex</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;清理函数：释放互斥锁\n&quot;</span>);<br>    pthread_mutex_unlock(&amp;mutex);<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">thread_work</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    pthread_mutex_lock(&amp;mutex); <span class="hljs-comment">// 加锁</span><br>    pthread_cleanup_push(cleanup_mutex, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 注册清理函数</span><br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 取消点：此处可接收取消请求</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程运行中...\n&quot;</span>);<br>    &#125;<br><br>    pthread_cleanup_pop(<span class="hljs-number">1</span>); <span class="hljs-comment">// 执行清理函数（实际不会执行，因线程被取消）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> tid;<br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, thread_work, <span class="hljs-literal">NULL</span>);<br><br>    sleep(<span class="hljs-number">3</span>); <span class="hljs-comment">// 让线程运行 3 秒</span><br>    pthread_cancel(tid); <span class="hljs-comment">// 发送取消请求</span><br>    pthread_join(tid, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 等待线程退出</span><br><br>    pthread_mutex_destroy(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">线程运行中...<br>线程运行中...<br>清理函数：释放互斥锁<br></code></pre></td></tr></table></figure><h3 id="5-线程同步：互斥锁、条件变量、读写锁"><a href="#5-线程同步：互斥锁、条件变量、读写锁" class="headerlink" title="5. 线程同步：互斥锁、条件变量、读写锁"></a>5. 线程同步：互斥锁、条件变量、读写锁</h3><p>线程间共享资源（如全局变量、文件）时，需通过同步机制避免数据竞争。以下通过示例讲解三种核心同步方式。</p><h4 id="（1）互斥锁：保证临界区互斥访问"><a href="#（1）互斥锁：保证临界区互斥访问" class="headerlink" title="（1）互斥锁：保证临界区互斥访问"></a>（1）互斥锁：保证临界区互斥访问</h4><p><strong>场景</strong>：两个线程同时对全局变量 <code>count</code> 自增 10000 次，需用互斥锁保证结果正确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">inc_count</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        pthread_mutex_lock(&amp;mutex);   <span class="hljs-comment">// 加锁：进入临界区</span><br>        count++;                     <span class="hljs-comment">// 临界区操作（共享变量自增）</span><br>        pthread_mutex_unlock(&amp;mutex); <span class="hljs-comment">// 解锁：退出临界区</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid1, tid2;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br><br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, inc_count, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, inc_count, <span class="hljs-literal">NULL</span>);<br><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最终 count 值: %d\n&quot;</span>, count); <span class="hljs-comment">// 正确输出 20000（无锁时可能小于 20000）</span><br>    pthread_mutex_destroy(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS Publisher与Subscriber节点代码解析</title>
    <link href="/2021/10/09/publish%E8%8A%82%E7%82%B9/"/>
    <url>/2021/10/09/publish%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="ROS-Publisher与Subscriber节点代码解析"><a href="#ROS-Publisher与Subscriber节点代码解析" class="headerlink" title="ROS Publisher与Subscriber节点代码解析"></a>ROS Publisher与Subscriber节点代码解析</h1><p>在ROS（Robot Operating System）中，<strong>节点（Node）</strong> 是连接到ROS网络的可执行文件，用于实现特定功能。本文将展示两个核心节点的代码：<code>Publisher（发布者）</code>节点（持续广播消息）和<code>Subscriber（订阅者）</code>节点（接收并处理消息），并对关键代码逻辑进行解析。</p><h2 id="1-Publisher节点（发布者：talker）"><a href="#1-Publisher节点（发布者：talker）" class="headerlink" title="1. Publisher节点（发布者：talker）"></a>1. Publisher节点（发布者：talker）</h2><p>Publisher节点的核心功能是：初始化ROS节点后，以固定频率在指定话题（<code>chatter</code>）上持续发布<code>std_msgs::String</code>类型的消息。</p><h3 id="1-1-完整代码"><a href="#1-1-完整代码" class="headerlink" title="1.1 完整代码"></a>1.1 完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 初始化ROS节点</span><br>    <span class="hljs-comment">// ros::init() 需传入argc和argv，用于解析命令行中的ROS参数与节点名称重映射</span><br>    <span class="hljs-comment">// 第三个参数&quot;talker&quot;是当前节点的名称（需保证ROS网络中唯一）</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;talker&quot;</span>);<br><br>    <span class="hljs-comment">// 2. 创建节点句柄（NodeHandle）</span><br>    <span class="hljs-comment">// NodeHandle是与ROS系统通信的&quot;总入口&quot;，用于创建Publisher/Subscriber、访问参数服务器等</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 3. 创建Publisher对象</span><br>    <span class="hljs-comment">// 函数参数说明：</span><br>    <span class="hljs-comment">// - &quot;chatter&quot;：要发布的话题名称</span><br>    <span class="hljs-comment">// - 1000：消息队列大小（若发布速度快于接收速度，队列满时会丢弃旧消息）</span><br>    <span class="hljs-comment">// - 模板类型std_msgs::String：发布的消息类型（需包含对应头文件）</span><br>    ros::Publisher chatter_pub = n.<span class="hljs-built_in">advertise</span>&lt;std_msgs::String&gt;(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>);<br><br>    <span class="hljs-comment">// 4. 设置循环频率</span><br>    <span class="hljs-comment">// ros::Rate用于控制节点的循环频率，参数&quot;10&quot;表示10Hz（即每秒循环10次）</span><br>    <span class="hljs-function">ros::Rate <span class="hljs-title">loop_rate</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><br>    <span class="hljs-comment">// 5. 消息计数变量（用于区分不同消息）</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 6. 核心循环（持续发布消息）</span><br>    <span class="hljs-comment">// ros::ok()：判断节点是否正常运行（如收到Ctrl+C终止指令时返回false）</span><br>    <span class="hljs-keyword">while</span> (ros::<span class="hljs-built_in">ok</span>()) &#123;<br>        <span class="hljs-comment">// 6.1 初始化消息对象</span><br>        std_msgs::String msg;<br>        std::stringstream ss;  <span class="hljs-comment">// 用于拼接字符串</span><br>        ss &lt;&lt; <span class="hljs-string">&quot;hello world &quot;</span> &lt;&lt; count;  <span class="hljs-comment">// 构造消息内容（如&quot;hello world 0&quot;, &quot;hello world 1&quot;...）</span><br>        msg.data = ss.<span class="hljs-built_in">str</span>();   <span class="hljs-comment">// 将字符串流内容赋值给消息的data字段（std_msgs::String的核心字段）</span><br><br>        <span class="hljs-comment">// 6.2 发布消息</span><br>        <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg.data.<span class="hljs-built_in">c_str</span>());  <span class="hljs-comment">// 打印消息到终端（类似printf，属于ROS日志函数）</span><br>        chatter_pub.<span class="hljs-built_in">publish</span>(msg);          <span class="hljs-comment">// 向&quot;chatter&quot;话题发布消息</span><br><br>        <span class="hljs-comment">// 6.3 处理回调（可选）</span><br>        <span class="hljs-comment">// ros::spinOnce()：触发一次回调函数处理（若当前节点同时订阅话题，需调用此函数）</span><br>        <span class="hljs-comment">// 本节点仅作为Publisher，此句可省略，但保留不影响功能</span><br>        ros::<span class="hljs-built_in">spinOnce</span>();<br><br>        <span class="hljs-comment">// 6.4 按设定频率延时</span><br>        <span class="hljs-comment">// loop_rate.sleep()：根据循环频率计算延时时间，确保循环稳定在10Hz</span><br>        loop_rate.<span class="hljs-built_in">sleep</span>();<br>        ++count;  <span class="hljs-comment">// 消息计数自增</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Subscriber节点（订阅者：listener）"><a href="#2-Subscriber节点（订阅者：listener）" class="headerlink" title="2. Subscriber节点（订阅者：listener）"></a>2. Subscriber节点（订阅者：listener）</h2><p>Subscriber节点的核心功能是：初始化ROS节点后，订阅<code>Publisher</code>发布的<code>chatter</code>话题，当收到消息时触发回调函数进行处理（如打印消息）。</p><h3 id="2-1-完整代码"><a href="#2-1-完整代码" class="headerlink" title="2.1 完整代码"></a>2.1 完整代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ros/ros.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;std_msgs/String.h&quot;</span></span><br><br><span class="hljs-comment">// 1. 回调函数（消息接收后自动执行）</span><br><span class="hljs-comment">// 参数说明：</span><br><span class="hljs-comment">// - const std_msgs::String::ConstPtr&amp; msg：指向接收消息的常量指针</span><br><span class="hljs-comment">//   使用ConstPtr避免拷贝，提高效率；Const确保消息不被修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chatterCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> std_msgs::String::ConstPtr&amp; msg)</span> </span>&#123;<br>    <span class="hljs-comment">// 打印接收到的消息（ROS_INFO是ROS的日志级别，终端会显示绿色信息）</span><br>    <span class="hljs-built_in">ROS_INFO</span>(<span class="hljs-string">&quot;I heard: [%s]&quot;</span>, msg-&gt;data.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 2. 初始化ROS节点</span><br>    <span class="hljs-comment">// 节点名称为&quot;listener&quot;，需与网络中其他节点名称唯一</span><br>    ros::<span class="hljs-built_in">init</span>(argc, argv, <span class="hljs-string">&quot;listener&quot;</span>);<br><br>    <span class="hljs-comment">// 3. 创建节点句柄（与Publisher节点功能一致，是ROS通信的入口）</span><br>    ros::NodeHandle n;<br><br>    <span class="hljs-comment">// 4. 创建Subscriber对象</span><br>    <span class="hljs-comment">// 函数参数说明：</span><br>    <span class="hljs-comment">// - &quot;chatter&quot;：要订阅的话题名称（必须与Publisher发布的话题一致）</span><br>    <span class="hljs-comment">// - 1000：消息队列大小（缓存未处理的消息，满时丢弃旧消息）</span><br>    <span class="hljs-comment">// - chatterCallback：消息回调函数（收到消息时自动调用此函数）</span><br>    ros::Subscriber sub = n.<span class="hljs-built_in">subscribe</span>(<span class="hljs-string">&quot;chatter&quot;</span>, <span class="hljs-number">1000</span>, chatterCallback);<br><br>    <span class="hljs-comment">// 5. 循环等待回调</span><br>    <span class="hljs-comment">// ros::spin()：进入无限循环，持续监听话题消息，收到消息后触发回调函数</span><br>    <span class="hljs-comment">// 此函数会阻塞当前线程，直到节点被终止（如Ctrl+C）</span><br>    ros::<span class="hljs-built_in">spin</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-核心概念补充"><a href="#3-核心概念补充" class="headerlink" title="3. 核心概念补充"></a>3. 核心概念补充</h2><p>为帮助理解代码逻辑，以下是ROS节点通信的核心概念总结：</p><table><thead><tr><th>概念</th><th>作用说明</th></tr></thead><tbody><tr><td><strong>节点（Node）</strong></td><td>ROS中的最小功能单元（可执行文件），如本文的<code>talker</code>（发布）和<code>listener</code>（订阅）。</td></tr><tr><td><strong>话题（Topic）</strong></td><td>节点间传递消息的”通道”，Publisher向话题发布消息，Subscriber从话题订阅消息。</td></tr><tr><td><strong>消息（Message）</strong></td><td>节点间传递的数据格式，如本文的<code>std_msgs::String</code>（字符串类型），ROS还提供激光、图像等复杂消息类型。</td></tr><tr><td><strong>回调函数（Callback）</strong></td><td>Subscriber接收消息后执行的函数，用于处理消息（如打印、数据解析）。</td></tr><tr><td><strong>节点句柄（NodeHandle）</strong></td><td>与ROS系统交互的核心对象，所有ROS通信（创建Publisher&#x2F;Subscriber）都需通过它。</td></tr><tr><td><strong>ROS日志函数</strong></td><td>如<code>ROS_INFO</code>（信息）、<code>ROS_WARN</code>（警告）、<code>ROS_ERROR</code>（错误），用于终端输出调试信息，区分不同日志级别。</td></tr></tbody></table><h2 id="4-代码运行说明"><a href="#4-代码运行说明" class="headerlink" title="4. 代码运行说明"></a>4. 代码运行说明</h2><p>若需运行上述代码，需完成以下步骤（以ROS Noetic为例）：</p><ol><li>在ROS工作空间的<code>src</code>目录下创建功能包（如<code>learning_topic</code>），依赖<code>roscpp</code>和<code>std_msgs</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_create_pkg learning_topic roscpp std_msgs<br></code></pre></td></tr></table></figure></li><li>将上述代码分别保存为<code>talker.cpp</code>和<code>listener.cpp</code>，放入功能包的<code>src</code>目录。</li><li>修改功能包的<code>CMakeLists.txt</code>，添加编译规则（指定可执行文件、依赖项）。</li><li>编译工作空间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/catkin_ws  <span class="hljs-comment"># 进入工作空间目录</span><br>catkin_make     <span class="hljs-comment"># 编译</span><br></code></pre></td></tr></table></figure></li><li>启动ROS核心（新终端）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">roscore<br></code></pre></td></tr></table></figure></li><li>运行Publisher节点（新终端）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash  <span class="hljs-comment"># 加载工作空间环境变量</span><br>rosrun learning_topic talker<br></code></pre></td></tr></table></figure></li><li>运行Subscriber节点（新终端）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br>rosrun learning_topic listener<br></code></pre></td></tr></table></figure></li><li>此时可在终端看到：<code>talker</code>持续输出<code>hello world X</code>，<code>listener</code>持续输出<code>I heard: [hello world X]</code>。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>科研， ros</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 基础核心知识点总结</title>
    <link href="/2021/03/09/c++/"/>
    <url>/2021/03/09/c++/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础核心知识点总结"><a href="#C-基础核心知识点总结" class="headerlink" title="C++ 基础核心知识点总结"></a>C++ 基础核心知识点总结</h1><p>本文系统梳理 C++ 基础语法、面向对象编程（OOP）核心特性及关键概念，涵盖内存管理、指针、多态、模板等高频考点，适合用于学习回顾或面试备考。</p><h2 id="一、C-基础语法与核心概念"><a href="#一、C-基础语法与核心概念" class="headerlink" title="一、C++ 基础语法与核心概念"></a>一、C++ 基础语法与核心概念</h2><h3 id="1-左值与右值引用"><a href="#1-左值与右值引用" class="headerlink" title="1. 左值与右值引用"></a>1. 左值与右值引用</h3><h4 id="1-1-左右值定义"><a href="#1-1-左右值定义" class="headerlink" title="1.1 左右值定义"></a>1.1 左右值定义</h4><ul><li><strong>左值（Lvalue）</strong>：可出现在赋值符号<code>=</code>左右两侧的值，代表一块可被访问的内存地址（如变量、数组元素、对象成员）。<br>示例：<code>int a = 5;</code> 中，<code>a</code>是左值，<code>5</code>是右值。</li><li><strong>右值（Rvalue）</strong>：仅能出现在赋值符号<code>=</code>右侧的值，通常是临时变量、字面量或表达式结果（无持久内存地址）。<br>示例：<code>a = b + 3;</code> 中，<code>b + 3</code>的结果是右值。</li></ul><h4 id="1-2-右值引用（C-11-新增）"><a href="#1-2-右值引用（C-11-新增）" class="headerlink" title="1.2 右值引用（C++11 新增）"></a>1.2 右值引用（C++11 新增）</h4><ul><li>定义：用<code>&amp;&amp;</code>声明，专门绑定右值（临时对象），延长其生命周期，避免不必要的拷贝。<br>示例：<code>int&amp;&amp; r = 10;</code>（<code>r</code>是右值引用，绑定临时变量<code>10</code>）。</li><li>核心用途：实现<strong>移动语义</strong>，解决深拷贝的性能问题（如<code>std::string</code>、<code>std::vector</code>的移动构造）。</li></ul><h4 id="1-3-邪道定义的局限性"><a href="#1-3-邪道定义的局限性" class="headerlink" title="1.3 邪道定义的局限性"></a>1.3 邪道定义的局限性</h4><p>“能被取地址的是左值，反之是右值”这一说法不严谨，因为：  </p><ul><li>无法对<strong>位域的某一位</strong>取地址（如<code>struct S &#123; int a : 4; &#125;; S s; &amp;s.a</code>非法）；  </li><li>无法对<strong>未命名临时对象的成员</strong>直接取地址（如<code>std::string(&quot;abc&quot;).c_str()</code>虽能获取字符地址，但对象本身是右值）。</li></ul><h3 id="2-移动语义与完美转发"><a href="#2-移动语义与完美转发" class="headerlink" title="2. 移动语义与完美转发"></a>2. 移动语义与完美转发</h3><h4 id="2-1-移动语义"><a href="#2-1-移动语义" class="headerlink" title="2.1 移动语义"></a>2.1 移动语义</h4><ul><li><strong>问题背景</strong>：传统深拷贝（如<code>std::vector</code>拷贝）需重新分配内存并复制数据，效率低；若源对象是临时变量（右值），拷贝后即被销毁，存在冗余。  </li><li><strong>解决方案</strong>：移动语义通过“浅拷贝+源对象置空”实现资源转移，避免内存重复分配。<br>示例：<code>std::vector&lt;int&gt; v1 = &#123;1,2,3&#125;; std::vector&lt;int&gt; v2 = std::move(v1);</code>（<code>v1</code>的内存资源转移给<code>v2</code>，<code>v1</code>变为空）。</li><li><strong>关键函数</strong>：<code>std::move()</code>本质是<code>static_cast&lt;T&amp;&amp;&gt;()</code>的封装，仅将左值“强制转换”为右值引用，不触发实际移动，移动操作由<strong>移动构造函数</strong>或<strong>移动赋值运算符</strong>完成。</li></ul><h4 id="2-2-完美转发"><a href="#2-2-完美转发" class="headerlink" title="2.2 完美转发"></a>2.2 完美转发</h4><ul><li><strong>问题背景</strong>：函数模板传递参数时，若参数是右值，可能因拷贝或类型转换变为左值，导致无法正确匹配移动语义。  </li><li><strong>解决方案</strong>：用<code>std::forward&lt;T&gt;()</code>保留参数的左右值属性，确保参数以“原始类型”传递给目标函数。<br>典型场景：模板函数转发参数至其他函数（如<code>std::make_unique</code>、<code>std::thread</code>）。</li></ul><p><strong>代码示例：完美转发的必要性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintT</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; t)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;lvalue: &quot;</span> &lt;&lt; t &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintT</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; t)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;rvalue: &quot;</span> &lt;&lt; t &lt;&lt; endl; &#125;<br><br><span class="hljs-comment">// 不使用完美转发：参数v会被转为左值</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(T v)</span> </span>&#123;<br>    <span class="hljs-built_in">PrintT</span>(v); <span class="hljs-comment">// 始终调用左值版本</span><br>&#125;<br><br><span class="hljs-comment">// 使用完美转发：保留v的左右值属性</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestForward</span><span class="hljs-params">(T&amp;&amp; v)</span> </span>&#123;<br>    <span class="hljs-built_in">PrintT</span>(forward&lt;T&gt;(v)); <span class="hljs-comment">// 左值传左值，右值传右值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">Test</span>(a);        <span class="hljs-comment">// 输出 &quot;lvalue: 5&quot;</span><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-number">10</span>);       <span class="hljs-comment">// 输出 &quot;lvalue: 10&quot;（右值被转为左值）</span><br>    <span class="hljs-built_in">TestForward</span>(a); <span class="hljs-comment">// 输出 &quot;lvalue: 5&quot;</span><br>    <span class="hljs-built_in">TestForward</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">// 输出 &quot;rvalue: 10&quot;（完美转发右值）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-智能指针（Smart-Pointer）"><a href="#3-智能指针（Smart-Pointer）" class="headerlink" title="3. 智能指针（Smart Pointer）"></a>3. 智能指针（Smart Pointer）</h3><p>智能指针是封装原始指针的类模板，自动管理内存（超出作用域时调用<code>delete</code>），避免内存泄漏和野指针问题。C++11 提供三种核心智能指针：</p><table><thead><tr><th>类型</th><th>核心特性</th><th>适用场景</th></tr></thead><tbody><tr><td><code>std::shared_ptr</code></td><td>共享所有权，内部维护<strong>引用计数</strong>（拷贝时计数+1，析构时计数-1，计数为0时释放内存）。</td><td>多个对象共享同一资源（如多线程共享数据）。</td></tr><tr><td><code>std::unique_ptr</code></td><td>独占所有权，禁止拷贝（仅支持移动），无引用计数开销，效率最高。</td><td>单一对象独占资源（如动态数组、局部动态对象）。</td></tr><tr><td><code>std::weak_ptr</code></td><td>弱引用，不增加<code>shared_ptr</code>的引用计数，可解决<code>shared_ptr</code>的<strong>循环引用</strong>问题。</td><td>观测<code>shared_ptr</code>管理的资源，避免循环引用。</td></tr></tbody></table><h4 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h4><ul><li><code>shared_ptr</code>避免循环引用：若两个<code>shared_ptr</code>互相指向对方，引用计数永远无法归零，导致内存泄漏（需用<code>weak_ptr</code>打破循环）。  </li><li><code>unique_ptr</code>的转移：通过<code>std::move()</code>转移所有权，转移后原<code>unique_ptr</code>变为空（不可再访问）。  </li><li><code>shared_ptr</code>线程安全：引用计数的增减是原子操作，但对象的读写需额外加锁（如<code>std::mutex</code>）。</li></ul><p><strong>代码示例：shared_ptr 循环引用问题</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;B&gt; b_ptr; <span class="hljs-comment">// A持有B的shared_ptr</span><br>    ~<span class="hljs-built_in">A</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;A destroyed&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    shared_ptr&lt;A&gt; a_ptr; <span class="hljs-comment">// B持有A的shared_ptr（循环引用）</span><br>    ~<span class="hljs-built_in">B</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;B destroyed&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    shared_ptr&lt;A&gt; a = <span class="hljs-built_in">make_shared</span>&lt;A&gt;();<br>    shared_ptr&lt;B&gt; b = <span class="hljs-built_in">make_shared</span>&lt;B&gt;();<br>    a-&gt;b_ptr = b; <span class="hljs-comment">// A指向B</span><br>    b-&gt;a_ptr = a; <span class="hljs-comment">// B指向A（循环引用）</span><br>    <span class="hljs-comment">// 退出作用域时，a和b的引用计数均为2，析构后变为1，内存泄漏</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 修复方案：将B的a_ptr改为weak_ptr&lt;B&gt;，不增加引用计数</span><br></code></pre></td></tr></table></figure><h3 id="4-C-与-C-语言的内存分配区别"><a href="#4-C-与-C-语言的内存分配区别" class="headerlink" title="4. C++ 与 C 语言的内存分配区别"></a>4. C++ 与 C 语言的内存分配区别</h3><p>C++ 继承 C 的内存管理逻辑，但通过<code>new/delete</code>增强了类型安全性和对象初始化能力，核心区别如下：</p><table><thead><tr><th>对比维度</th><th>C++ <code>new/delete</code></th><th>C <code>malloc/free</code></th></tr></thead><tbody><tr><td><strong>操作本质</strong></td><td>运算符（可重载）</td><td>标准库函数</td></tr><tr><td><strong>内存位置</strong></td><td>自由存储区（通常与堆重叠，但由编译器决定）</td><td>堆（Heap）</td></tr><tr><td><strong>类型检查</strong></td><td>按类型分配，返回对应类型指针（无需强转）</td><td>按字节分配，返回<code>void*</code>（需显式强转）</td></tr><tr><td><strong>对象初始化</strong></td><td>调用构造函数（如<code>new int(10)</code>初始化值为10）</td><td>仅分配内存，不初始化（值为随机）</td></tr><tr><td><strong>对象销毁</strong></td><td>调用析构函数（释放资源，如动态成员）</td><td>仅释放内存，不调用析构（可能内存泄漏）</td></tr><tr><td><strong>错误处理</strong></td><td>内存分配失败抛出<code>std::bad_alloc</code>异常</td><td>返回<code>NULL</code>指针</td></tr><tr><td><strong>数组支持</strong></td><td><code>new[]</code>分配数组，<code>delete[]</code>释放（需匹配）</td><td>需手动计算字节数（如<code>malloc(5*sizeof(int))</code>）</td></tr></tbody></table><h4 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h4><ul><li><p><strong><code>malloc</code></strong>：  </p><ol><li>小内存（&lt;128KB）：调用<code>brk()</code>调整堆顶指针（<code>sbrk</code>），分配连续内存；  </li><li>大内存（≥128KB）：调用<code>mmap()</code>在文件映射区分配独立内存块；  </li><li>内存池管理：采用“隐式链表”维护空闲块，减少系统调用开销，避免内存碎片。</li></ol></li><li><p><strong><code>new</code></strong>：  </p><ol><li>调用<code>operator new</code>分配内存（底层可调用<code>malloc</code>或自定义逻辑）；  </li><li>调用对象的构造函数（初始化成员、分配资源）；  </li><li>返回对象指针；  </li><li>释放时，<code>delete</code>先调用析构函数，再调用<code>operator delete</code>释放内存。</li></ol></li></ul><h3 id="5-struct-与-class-的区别"><a href="#5-struct-与-class-的区别" class="headerlink" title="5. struct 与 class 的区别"></a>5. <code>struct</code> 与 <code>class</code> 的区别</h3><p>C++ 中<code>struct</code>是<code>class</code>的“简化版”，核心区别在于<strong>默认访问权限</strong>和<strong>默认继承方式</strong>，其余功能（如成员函数、继承、多态）完全一致：</p><table><thead><tr><th>特性</th><th><code>struct</code></th><th><code>class</code></th></tr></thead><tbody><tr><td><strong>默认访问权限</strong></td><td>成员默认<code>public</code>（外部可直接访问）</td><td>成员默认<code>private</code>（仅内部&#x2F;友元可访问）</td></tr><tr><td><strong>默认继承方式</strong></td><td>默认公有继承（<code>public</code>）</td><td>默认私有继承（<code>private</code>）</td></tr><tr><td><strong>模板参数支持</strong></td><td>不能作为模板参数（如<code>template &lt;struct T&gt;</code>非法）</td><td>可作为模板参数（如<code>template &lt;class T&gt;</code>合法）</td></tr><tr><td><strong>使用场景</strong></td><td>通常用于存储数据结构（如<code>struct Point &#123; int x; int y; &#125;</code>）</td><td>用于封装对象（含属性和方法，强调OOP）</td></tr></tbody></table><h3 id="6-异常处理机制"><a href="#6-异常处理机制" class="headerlink" title="6. 异常处理机制"></a>6. 异常处理机制</h3><p>C++ 提供<code>try-catch-throw</code>异常处理模型，用于捕获和处理运行时错误（如内存分配失败、数组越界），替代 C 语言的<code>abort()</code>&#x2F;<code>exit()</code>（强制终止程序）。</p><h4 id="核心语法"><a href="#核心语法" class="headerlink" title="核心语法"></a>核心语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 可能抛出异常的代码</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 错误条件 */</span>) &#123;<br>        <span class="hljs-keyword">throw</span> 异常值; <span class="hljs-comment">// 抛出异常（类型可自定义，如int、string、自定义类）</span><br>    &#125;<br>&#125; <span class="hljs-built_in">catch</span> (异常类型<span class="hljs-number">1</span>&amp; e) &#123;<br>    <span class="hljs-comment">// 处理类型1的异常</span><br>&#125; <span class="hljs-built_in">catch</span> (异常类型<span class="hljs-number">2</span>&amp; e) &#123;<br>    <span class="hljs-comment">// 处理类型2的异常</span><br>&#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>    <span class="hljs-comment">// 捕获所有未匹配的异常（兜底处理）</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关键特性"><a href="#关键特性" class="headerlink" title="关键特性"></a>关键特性</h4><ul><li><strong>异常传播</strong>：若<code>try</code>块中抛出的异常未被当前<code>catch</code>捕获，会向上传播至调用栈，直至找到匹配的<code>catch</code>或程序终止。  </li><li><strong>标准异常</strong>：C++ 标准库提供异常类体系（如<code>std::bad_alloc</code>、<code>std::out_of_range</code>），可直接抛出或继承扩展。  </li><li><strong>资源安全</strong>：异常抛出时，局部对象会自动调用析构函数（“栈展开”机制），避免资源泄漏（推荐用 RAII 模式管理资源，如智能指针）。</li></ul><h3 id="7-深拷贝与浅拷贝"><a href="#7-深拷贝与浅拷贝" class="headerlink" title="7. 深拷贝与浅拷贝"></a>7. 深拷贝与浅拷贝</h3><p>拷贝是对象复制的过程，核心区别在于<strong>是否重新分配资源</strong>（如动态内存、文件句柄）：</p><table><thead><tr><th>类型</th><th>实现方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>浅拷贝</strong></td><td>位拷贝（默认拷贝构造函数&#x2F;赋值运算符），仅复制成员值，不复制资源。</td><td>效率高（无额外内存分配）</td><td>多个对象共享资源，析构时可能重复释放（崩溃）或内存泄漏。</td></tr><tr><td><strong>深拷贝</strong></td><td>显式定义拷贝构造函数&#x2F;赋值运算符，为新对象重新分配资源并复制内容。</td><td>资源独立（无共享问题）</td><td>效率低（需分配内存+复制</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>hi，这里是最爱的杂货铺</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<h2 id="about-me"><a href="#about-me" class="headerlink" title="about me"></a>about me</h2><p><strong>tel</strong>：18258866903<br><strong>email</strong>：<a href="mailto:&#x72;&#101;&#110;&#106;&#x69;&#101;&#45;&#x6c;&#x40;&#x66;&#x6f;&#x78;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#x6d;">renjie-l@foxmail.com</a></p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><ul><li>杭州电子科技大学，硕士研究生，电子信息专业，2020.09 – 2023.06</li><li>ITMO UNIVERSITY，Master，Control Engineering专业，2020.09 – 2022.06</li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"><a href="#基于强化学习的无人机负载无摆动轨迹生成（科研项目）" class="headerlink" title="基于强化学习的无人机负载无摆动轨迹生成（科研项目）"></a>基于强化学习的无人机负载无摆动轨迹生成（科研项目）</h3><ul><li><strong>项目背景</strong>：浙江省新苗人才计划项目</li><li><strong>项目时间</strong>：2022.03 – 2023.06</li><li><strong>项目描述</strong>：针对无人机悬挂负载易摆动的问题，通过强化学习算法生成无摆动飞行轨迹，并在实际无人机系统中验证有效性。</li></ul><h2 id="所获奖励"><a href="#所获奖励" class="headerlink" title="所获奖励"></a>所获奖励</h2><ul><li>2021年7月：第十六届中国研究生电子设计竞赛 华东赛区一等奖</li><li>2022年8月：第八届浙江省“互联网+”创新创业大赛 银奖</li><li>2021年10月：2021研究生学业奖学金（前10%）</li><li>2020年11月：2020研究生学业奖学金（前20%）</li></ul><h2 id="学术论文"><a href="#学术论文" class="headerlink" title="学术论文"></a>学术论文</h2><ul><li>Renjie, L., &amp; Fan, Y. (2022). Deep Reinforcement Learning-based Swing-Free Trajectories Planning Algorithm for UAV with a Suspended Load. In Proceedings of the CAC CHINAAUTOMATIONCONGRESS 2022.</li></ul>]]></content>
    
  </entry>
  
  
  
</search>
